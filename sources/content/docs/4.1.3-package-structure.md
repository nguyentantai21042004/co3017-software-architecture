# 4.1.3 Cấu trúc Gói (Package Structure)

## Mục tiêu
- Chuẩn hóa và minh họa cấu trúc gói của `Content Service` theo định hướng Clean Architecture và quyết định ADR-1 (Polyglot Strategy).
- Làm rõ cách Java service này tổ chức mã nguồn, giúp đội ngũ dễ dàng đối chiếu khi mở rộng sang ngôn ngữ khác (Go, v.v.).

## a. Service Java (Content Service)

### Ảnh chụp cấu trúc thư mục trọng tâm
```text
src/main/java/co3017/microservices/content_service/
├── adapter/
│   └── http/                    # REST controllers, DTOs, response builders
├── config/                      # Spring Boot entry point, cross-cutting config
├── mappers/                     # Domain ↔ Persistence transformers
├── models/                      # Domain entities & value objects
├── repository/                  # Ports (interfaces) & Postgres adapters
│   └── postgresql/
│       ├── entity/              # JPA entities
│       ├── mapper/              # Persistence-specific mappers
│       ├── specification/       # Query specifications (criteria builders)
│       └── SpringData...        # Spring Data repositories + adapters
└── usecase/                     # Application layer contracts & services
    ├── service/                 # Use case implementations (business orchestration)
    └── types/                   # Commands, queries, DTOs cho use cases

src/main/resources/              # Infrastructure config (YAML, SQL migrations)
```

### Ánh xạ vào 4 tầng Clean Architecture

- **Domain Layer (`models/`, `repository/*.java`)**
  - `models/` chứa các Aggregate Root và Value Object (ví dụ `Course`, `ContentUnit`, `MetadataTag`). Các lớp thuần Java, không phụ thuộc framework, tập trung business invariants (ví dụ `Course#isValid`, `updateTitle`).
  - `repository/` định nghĩa các Port Out (interfaces) như `CourseRepository`, `ContentVersionRepository`. Chúng chỉ làm việc với domain model và DTO thuộc use case, đảm bảo Domain độc lập với kỹ thuật lưu trữ.

- **Application Layer (`usecase/`)**
  - Các interface `CourseUseCase`, `ContentUnitUseCase`, ... bao quát toàn bộ hành vi business (Create/Read/Update/Delete/Search).
  - `usecase/service/` cung cấp implementation (ví dụ `CourseService`) chịu trách nhiệm điều phối Domain model, kiểm tra business rule, gọi Port. Các class này đánh dấu `@Service` và `@Transactional`, nhưng logic vẫn sạch và dễ test (chỉ phụ thuộc interface của Domain).
  - `usecase/types/` gom nhóm command/query (ví dụ `CreateCourseCommand`, `CourseSearchCriteria`) và return types (`CoursePageResult`). Đây là DTO thuần Java giúp Application layer độc lập với adapter đầu vào/đầu ra cụ thể.

- **Interface Adapters Layer (`adapter/http`, `mappers/`)**
  - `adapter/http/` chứa controller REST (ví dụ `CourseController`) cùng DTO request/response. Controllers chuyển đổi HTTP payload ↔ `usecase.types` thông qua builder (`CommandBuilder`, `CourseResponseBuilder`). Giao diện HTTP vì vậy không rò rỉ chi tiết Domain.
  - `mappers/` chịu trách nhiệm chuyển đổi giữa Domain (ở `models/`) và persistence entity (ở infrastructure). Dù hiện mapper được Spring quản lý, chúng không sử dụng annotation đặc thù, nên có thể tái dùng ở ngữ cảnh khác.

- **Infrastructure Layer (`repository/postgresql`, `config/`, `resources/`)**
  - `repository/postgresql/` triển khai Port Out bằng Spring Data JPA. Ví dụ `JpaCourseRepository` sử dụng `SpringDataCourseRepository` (extends `JpaRepository`) và mapper để chuyển đổi `CourseEntity` ↔ `Course`. Các `Specification` cung cấp dynamic query phục vụ search.
  - `config/` chứa `ContentServiceApplication` (entry point) và cấu hình phụ trợ (`CorsConfig`). Phần này gắn Domain/Application vào Spring Boot thông qua component scan, JPA entity scan.
  - `resources/` lưu cấu hình môi trường (`application.yml`, profile overrides) và script SQL khởi tạo. Đây là hạ tầng triển khai, không ảnh hưởng tới Domain/Application.

### Mối tương quan với Polyglot Strategy (ADR-1)
- Việc tách biệt 4 tầng rõ ràng giúp áp dụng cùng một blueprint khi hiện thực service bằng ngôn ngữ khác (Go). Các package có vai trò tương đương thư mục Go (domain, application, adapters, infrastructure).
- DTO thuần Java (`usecase/types`, `adapter/http/dto`) và Port interface (`repository/`) đóng vai trò “ngôn ngữ chung”, dễ chuyển đổi sang struct/interface trong Go.
- Mapper lớp mỏng giữa Domain và Entity gợi ý giữ Domain thuần và đẩy kỹ thuật persistence xuống hạ tầng – phù hợp với chiến lược đa ngôn ngữ nơi mỗi runtime có thể sử dụng ORM/driver riêng.

### Đánh giá & Gợi ý hoàn thiện
- **Tính nhất quán**: Cấu trúc đã bám sát Clean Architecture. Domain không phụ thuộc Spring; Application layer chỉ phụ thuộc Port interface. REST adapter không truy cập persistence trực tiếp.
- **Tên thư mục**: Có thể cân nhắc đổi `models/` → `domain/` và `repository/` → `domain/ports` để phản ánh rõ tầng Domain, tránh nhầm lẫn với infrastructure repository.
- **Đóng gói adapter**: `adapter/http/dto` và `adapter/http/response` hiện thuần Java, có thể gom về `adapter/http` hoặc đặt tên theo “controller/dto/builder” để giảm phân mảnh.
- **Cross-service reuse**: Nên trích xuất template tree vào tài liệu kiến trúc chung, giúp các service polyglot (Go) tái sử dụng chuẩn: `domain/`, `application/`, `interfaces/`, `infrastructure/`.
- **Kiểm thử**: Thư mục `src/test/java` hiện trống cho Content Service; nên bổ sung test cho Domain và Application layer để đảm bảo tuân thủ boundary (không cần Spring context).

### Kết luận
Cấu trúc `Content Service` hiện tại thể hiện rõ 4 vòng tròn của Clean Architecture và tương thích với chiến lược polyglot. Việc điều chỉnh nhỏ về naming và tài liệu hóa template sẽ giúp đội ngũ tái sử dụng mô hình này khi triển khai service mới bằng Java hay Go, đảm bảo tính nhất quán toàn hệ thống.


