## Tổng quan Use Case & Domain Model

### 1. Mô tả Use Case (Ánh xạ từ User Stories)
Use case làm rõ các bước tương tác giữa Actor và hệ thống; là cơ sở cho các Sequence Diagram ở bước 1.4.

| Usecase ID | Tên Usecase                            | Mục đích                                                                         | Tác nhân   | FR liên quan | Luồng Cơ bản (Basic Flow) |
|------------|----------------------------------------|----------------------------------------------------------------------------------|------------|--------------|---------------------------|
| **UC-01**  | Đăng ký Tài khoản                      | Tạo tài khoản mới trong hệ thống.                                               | Learner, Instructor, Admin | FR1 | 1. User truy cập trang đăng ký. 2. Nhập email, password, chọn role (Learner/Instructor). 3. Hệ thống validate và tạo tài khoản. 4. Gửi email xác nhận. 5. User xác nhận email và kích hoạt tài khoản. |
| **UC-02**  | Đăng nhập & Xác thực                   | Cho phép người dùng đăng nhập và truy cập hệ thống.                              | Learner, Instructor, Admin | FR1, FR11 | 1. User nhập email và password. 2. Hệ thống xác thực thông tin. 3. Kiểm tra role và phân quyền (RBAC). 4. Tạo session và chuyển đến dashboard tương ứng với role. |
| **UC-03**  | Cập nhật Hồ sơ & Cài đặt Học tập       | Learner cập nhật thông tin cá nhân và tùy chọn học tập.                          | Learner    | FR2 | 1. Learner truy cập trang hồ sơ. 2. Cập nhật tên, tuổi, trình độ, sở thích, mục tiêu, lịch học. 3. Thiết lập nhắc nhở (email/push). 4. Hệ thống lưu thông tin vào LearnerProfile. |
| **UC-04**  | Thực hiện Bài kiểm tra Đầu vào        | Đánh giá kiến thức ban đầu để xây dựng Learner Model.                            | Learner    | FR2, FR5 | 1. Learner bắt đầu diagnostic test. 2. Hệ thống hiển thị câu hỏi đa dạng về kỹ năng. 3. Learner trả lời. 4. Hệ thống chấm điểm và tạo SkillMasteryScore. 5. Kết quả lưu vào LearnerModel. |
| **UC-05**  | Tạo Khóa học & Nội dung Học tập        | Instructor tạo khóa học, chương, bài học với đa dạng định dạng.                  | Instructor | FR3 | 1. Instructor tạo khóa học mới. 2. Tạo chương và bài học (text, video, slide, quiz, coding task). 3. Cấu hình versioning và phân quyền (public/private/group). 4. Lưu vào ContentAggregate. |
| **UC-06**  | Gắn Metadata & Tagging cho Nội dung   | Instructor gắn metadata để hỗ trợ thuật toán AI.                                 | Instructor | FR3, FR4 | 1. Instructor chọn nội dung đã tạo. 2. Gắn tags: kỹ năng, độ khó, chủ đề. 3. Hệ thống lưu MetadataTag. 4. ContentMetadata có sẵn cho Adaptive Engine. |
| **UC-07**  | Cấu hình Lộ trình Khóa học             | Instructor thiết lập mục tiêu, milestones, điều kiện mở khóa bài học.            | Instructor | FR4 | 1. Instructor định nghĩa mục tiêu khóa học và kỹ năng yêu cầu. 2. Thiết lập pre-test, post-test. 3. Cấu hình điều kiện mở khóa (ví dụ: ≥70% điểm quiz). 4. Lưu cấu trúc lộ trình. |
| **UC-08**  | Bắt đầu/Tiếp tục Học tập Thích ứng     | Cung cấp bài học tiếp theo tối ưu dựa trên Learner Model.                        | Learner    | FR7, FR4 | 1. Learner yêu cầu bài học tiếp theo. 2. Hệ thống gọi Adaptive Engine (FR7). 3. Engine đọc LearnerModel và ContentMetadata. 4. Đề xuất ContentID tối ưu (spaced repetition, mastery-based). 5. Hiển thị nội dung. |
| **UC-09**  | Làm Bài tập & Assessment               | Learner thực hiện bài tập (MCQ, essay, coding, upload, project).                 | Learner    | FR5 | 1. Learner mở bài tập. 2. Đọc đề và trả lời (trong thời gian giới hạn nếu có). 3. Submit câu trả lời. 4. Hệ thống lưu vào gradebook. |
| **UC-10**  | Chấm điểm & Phản hồi Tức thì           | Hệ thống chấm điểm và cung cấp phản hồi/gợi ý ngay lập tức.                      | Learner    | FR5, FR6 | 1. Learner gửi câu trả lời (FR5). 2. Scoring/Feedback Service chấm điểm (auto-grading hoặc manual review). 3. Tạo feedback, hints, giải thích đáp án. 4. Hiển thị Score và Hint (< 500ms). 5. Cập nhật LearnerModel. |
| **UC-11**  | Gợi ý Bài học Bù (Remediation)         | Đề xuất bài học bổ sung khi Learner yếu kỹ năng.                                 | Learner    | FR6, FR7 | 1. Hệ thống phát hiện kỹ năng yếu từ LearnerModel. 2. FeedbackGenerator tạo gợi ý bài học liên quan. 3. Hiển thị danh sách bài học bù với hướng dẫn step-by-step. 4. Learner chọn bài học để học lại. |
| **UC-12**  | Xem Dashboard & Tiến độ Học tập        | Learner xem tiến độ, điểm số, milestones.                                        | Learner    | FR8 | 1. Learner truy cập dashboard. 2. Hệ thống hiển thị tiến độ, điểm số, lịch học, milestones, skill mastery. 3. Learner có thể xuất báo cáo (CSV/PDF). |
| **UC-13**  | Xem Báo cáo Tổng hợp Lớp               | Instructor xem tổng quan hiệu suất của cả lớp.                                   | Instructor | FR8 | 1. Instructor chọn lớp. 2. Hệ thống tạo báo cáo tổng hợp: điểm trung bình, điểm yếu phổ biến, phân bố kỹ năng. 3. Instructor phân tích và điều chỉnh nội dung. |
| **UC-14**  | Tạo Báo cáo Chi tiết Học sinh          | Instructor tạo báo cáo cá nhân hóa cho một học sinh.                              | Instructor | FR8 | 1. Instructor chọn học sinh. 2. Hệ thống truy xuất LearnerModel, ProgressRecord. 3. Tạo báo cáo: lộ trình học, điểm mạnh/yếu, thời gian học. 4. Xuất PDF/CSV để tư vấn one-on-one. |
| **UC-15**  | Tương tác & Thảo luận                  | Learner/Instructor tham gia thảo luận, chat, bình luận.                          | Learner, Instructor | FR9 | 1. User truy cập diễn đàn hoặc bài học. 2. Gửi comment/câu hỏi. 3. Hệ thống gửi thông báo realtime (in-app/email/push) cho người liên quan. 4. User khác trả lời. |
| **UC-16**  | Quản lý Lớp & Phân nhóm                | Instructor tạo lớp, mời học sinh, chia nhóm.                                     | Instructor | FR10 | 1. Instructor tạo lớp mới. 2. Mời học sinh qua email/link. 3. Phân vai trò (TA, student, observer). 4. Chia nhóm cho project. 5. Giao bài nhóm và đánh giá theo nhóm. |
| **UC-17**  | Quản lý Người dùng & Phân quyền (RBAC) | Admin quản lý tài khoản và phân quyền chi tiết.                                  | Admin      | FR1, FR11 | 1. Admin truy cập trang quản lý users. 2. Tạo/sửa/xóa tài khoản. 3. Gán role và permissions. 4. Mọi thao tác ghi vào audit logs. 5. User chỉ truy cập tính năng được phép. |
| **UC-18**  | Hoán đổi Mô hình AI (Live Swap)        | Triển khai phiên bản AI mới không downtime.                                      | Admin      | FR12 | 1. Admin yêu cầu triển khai Model V2. 2. Deployment Service chạy V2 song song với V1. 3. Traffic chuyển dần sang V2 (Blue/Green/Canary). 4. Monitoring kiểm tra health. 5. Ngừng V1 khi V2 ổn định. |
| **UC-19**  | Giám sát & Vận hành Hệ thống           | Admin quản lý cấu hình, backup, logs, moderation.                                | Admin      | FR12 | 1. Admin truy cập admin panel. 2. Kiểm tra health checks, logs hệ thống. 3. Thực hiện backup/restore dữ liệu. 4. Xử lý báo cáo vi phạm (moderation). 5. Cấu hình hệ thống (feature flags, limits). |
| **UC-20**  | Nhận Phần thưởng & Gamification        | Learner nhận XP, badges, tham gia leaderboard.                                   | Learner    | FR13 | 1. Learner hoàn thành bài học/milestone. 2. Hệ thống tính XP, trao badge. 3. Cập nhật leaderboard. 4. Hiển thị streak learning, challenge mode. 5. Learner được động viên tiếp tục học. |

### 2. Mô hình hóa Domain chi tiết (ERD/Domain Model)

#### Vai trò chiến lược của Domain Model

Phần Mô hình hóa Domain chi tiết không chỉ là sơ đồ ERD tĩnh mà là **khung tư duy chiến lược** giúp ra quyết định kiến trúc ở cấp độ vĩ mô và vi mô. Nó đóng vai trò là **cầu nối giữa yêu cầu nghiệp vụ và cấu trúc kỹ thuật**, giải quyết 4 vấn đề cốt lõi:

##### **1. Phân rã hệ thống thành các Service/Component độc lập**

**Mục tiêu:** Xác định **ranh giới (boundaries)** dựa trên ngữ nghĩa nghiệp vụ để tạo cơ sở cho kiến trúc Microservices.

**Vai trò phân tích:** 
- Giúp hiểu rõ mối quan hệ và phụ thuộc giữa các thành phần hệ thống
- Cung cấp cơ sở cho việc thiết kế kiến trúc phân tán linh hoạt
- Hỗ trợ ra quyết định về khả năng mở rộng và bảo trì hệ thống

**Ví dụ cụ thể:**

| **Khối Domain** | **Vấn đề Nghiệp vụ** | **Hành động Kiến trúc** | **Kết quả** |
|----------------|---------------------|------------------------|-------------|
| **LearnerModelAggregate** | - Cần cập nhật liên tục (mỗi lần làm bài)<br>- Tính toán AI nặng (BKT algorithm)<br>- Thay đổi logic không ảnh hưởng profile | Tách thành **LearnerModel Service** riêng | Cho phép deploy AI độc lập<br>Khả năng scale riêng khi nhiều user |
| **ContentAggregate** | - Dữ liệu ít thay đổi<br>- Nhiều service phụ thuộc (Engine, Dashboard, Feedback) | Tách thành **Content Management Service** với I≈0 | Reliability cao<br>Caching hiệu quả |
| **AdaptivePathGenerator** | - Cần hoán đổi thuật toán AI dễ dàng | Đặt trong **Adaptive Engine Service** độc lập | Blue/Green deployment<br>A/B testing algorithms |

**Quy tắc phân rã:**
- Mỗi Aggregate Root → Ứng viên cho 1 Microservice
- Aggregates có tần suất thay đổi khác nhau → Tách riêng
- Aggregates cần scale độc lập → Tách riêng

---

##### **2. Áp dụng nghiêm ngặt SOLID Principles**

**Mục tiêu:** Đảm bảo code maintainable, extensible, testable.

**Vai trò phân tích:**
- Cung cấp nguyên tắc thiết kế để tạo mã nguồn chất lượng cao
- Giúp dự đoán và quản lý sự phức tạp của hệ thống
- Tạo nền tảng cho việc mở rộng và bảo trì dễ dàng

**Ánh xạ SOLID vào Domain Model:**

| **Nguyên tắc** | **Áp dụng trong Domain** | **Ví dụ ITS** |
|---------------|-------------------------|---------------|
| **SRP** | Mỗi Aggregate chỉ có 1 lý do thay đổi | Tách LearnerAggregate (dữ liệu cá nhân) khỏi LearnerModelAggregate (AI state). Khi logic AI thay đổi, profile không ảnh hưởng. |
| **DIP** | Policy modules phụ thuộc vào Interface | AdaptivePathGenerator (Policy) phụ thuộc LearnerModelRepository Interface, không phải PostgreSQL cụ thể. |
| **OCP** | Mở rộng không sửa code cũ | MetadataTag mở rộng qua tagging (thêm tag mới), không sửa schema ContentUnit. |
| **ISP** | Interface nhỏ, focused | LearnerRepository tách thành LearnerReadRepository và LearnerWriteRepository. Scoring Service chỉ dùng Read. |
| **LSP** | Subtype thay thế được supertype | QuizAssessment và ProjectAssessment đều implement Assessment interface, đảm bảo polymorphism. |

---

##### **3. Đảm bảo Testability & Maintainability**

**Mục tiêu:** Logic nghiệp vụ độc lập với I/O, dễ test.

**Vai trò phân tích:**
- Cung cấp phương pháp thiết kế giúp kiểm thử dễ dàng
- Tách biệt logic nghiệp vụ khỏi các chi tiết kỹ thuật
- Tạo nền tảng cho việc bảo trì và mở rộng hệ thống một cách linh hoạt

**Chiến lược:**

**A. Tách Domain Services khỏi Aggregates**

| **Cách làm** | **Lợi ích** | **Ví dụ ITS** |
|-------------|-------------|---------------|
| Logic nghiệp vụ → Domain Service (stateless) | Dễ Mock/Test | ScoringEngine (service) tách khỏi Assessment (aggregate). Test scoring logic với mock Assessment. |
| Aggregates chỉ chứa data + validation | Lightweight, dễ serialize | LearnerModel chỉ chứa scores, không có logic tính toán. |
| Domain Services phụ thuộc Interface | Unit test không cần DB | FeedbackGenerator → Mock ErrorType interface. |

---

##### **4. Hỗ trợ ra quyết định kiến trúc**

**Mục tiêu:** Đánh giá Chỉ số Bất ổn (I) và phụ thuộc để chọn Architecture Pattern.

**Vai trò phân tích:**
- Cung cấp phương pháp định lượng để đánh giá độ ổn định của các thành phần hệ thống
- Hỗ trợ ra quyết định về cấu trúc kiến trúc phần mềm
- Giúp xác định các điểm cần tập trung tối ưu hóa

**Công thức Instability Index:**

Công thức: I = Cₑ / (Cₑ + Cₐ)

Trong đó:
- **Cₑ (Efferent Coupling):** Số dependencies đi ra (module này phụ thuộc bao nhiêu module khác)
- **Cₐ (Afferent Coupling):** Số dependencies đi vào (bao nhiêu module khác phụ thuộc module này)
- **I = 0:** Rất ổn định (nhiều module phụ thuộc, ít thay đổi)
- **I = 1:** Rất bất ổn (không ai phụ thuộc, tự do thay đổi)

**Ví dụ tính I cho ITS:**

| **Module** | **Cₐ (Incoming)** | **Cₑ (Outgoing)** | **I = Cₑ/(Cₑ+Cₐ)** | **Giải thích** |
|-----------|------------------|------------------|-------------------|---------------|
| **ContentService** | 4 (Engine, Feedback, Dashboard, Learner) | 0 | 0/(0+4) = 0 | Rất ổn định - Source of Truth cho metadata. Nhiều service phụ thuộc. |
| **AdaptiveEngine** | 2 (Learner Dashboard, UC-08 flow) | 2 (LearnerModel, Content) | 2/(2+2) = 0.5 | Vừa phải - Policy module, nhưng cần đọc data từ 2 services. |
| **LearnerModel** | 3 (Engine, Feedback, Dashboard) | 1 (Content for tags) | 1/(1+3) = 0.25 | Tương đối ổn định - Core state nhiều service cần. |
| **ScoringService** | 1 (Learner submit) | 3 (Assessment, LearnerModel, Feedback) | 3/(3+1) = 0.75 | Bất ổn - Orchestrator phụ thuộc nhiều service, logic thay đổi nhiều. |

**Hành động:**
- **I ≈ 0:** Cần High Availability, Caching, Read Replicas (Content, LearnerModel)
- **I → 1:** Dễ deploy riêng, Blue/Green friendly (ScoringService, FeedbackGenerator)
- **I ≈ 0.5:** Cần monitoring tight, critical path (AdaptiveEngine)

---

#### A. Core Aggregates và Entities

##### Khái niệm Aggregate

**Định nghĩa:**
- **Aggregate**: Cụm các thực thể liên kết logic với nhau, có **ranh giới nhất quán (consistency boundary)** và một **Aggregate Root** quản lý.
- **Aggregate Root**: Entity chính làm **điểm truy cập duy nhất** cho toàn bộ Aggregate, đảm bảo tính toàn vẹn dữ liệu (business invariants).
- **Vai trò kiến trúc**: Mỗi Aggregate là ứng viên tiềm năng để trở thành một **Microservice** hoặc **Bounded Context** riêng.

**Vai trò phân tích:**
- Cung cấp phương pháp tổ chức dữ liệu theo logic nghiệp vụ
- Giúp xác định ranh giới và mối quan hệ giữa các thành phần hệ thống
- Hỗ trợ thiết kế kiến trúc phân tán với tính nhất quán cao

**Quy tắc Aggregate (Theo DDD):**
1. **Transaction Boundary**: Một transaction chỉ cập nhật 1 Aggregate (không span cross-aggregate).
2. **Reference by ID**: Aggregates khác chỉ tham chiếu qua ID, không giữ object reference.
3. **Eventual Consistency**: Cập nhật cross-aggregate dùng Events (async).

**Minh họa Aggregate Boundary:**

Ví dụ về LearnerAggregate và LearnerModelAggregate:
- **LearnerAggregate**: Chứa thông tin cá nhân và tiến trình học tập của người học
- **LearnerModelAggregate**: Lưu trữ trạng thái học tập và điểm số AI

**Tại sao tách riêng?**
- **LearnerAggregate**: Thay đổi khi user update profile (thường - vài lần/ngày)
- **LearnerModelAggregate**: Thay đổi MỖI LẦN làm bài (rất thường - hàng chục lần/ngày)
- → Nếu chung Aggregate, mọi lần làm bài đều lock toàn bộ Learner data → Bottleneck!

---

##### Bảng Chi Tiết Core Aggregates

| **Tên Domain Aggregate** | **Core Entities** | **Business Invariants** | **Vai trò & Quyết định Kiến trúc** |
|------------------------|-------------------|------------------------|--------------------------------|
| **LearnerAggregate** | - Learner (Root)<br>- LearnerProfile<br>- ProgressRecord | - Email unique<br>- Profile belongs to 1 Learner<br>- Progress % ∈ [0, 100] | **Vai trò**: Quản lý thông tin cá nhân, tiến trình học tập (FR2, UC-03).<br><br>**Quyết định**: Tách thành **User Management Service** (Java/Spring Boot).<br><br>**SOLID Rationale**:<br>- **SRP**: Chỉ quản lý dữ liệu người dùng, KHÔNG chứa logic AI.<br>- **Lý do tách**: Khi AI algorithm thay đổi, không cần redeploy User Management.<br><br>**Architecture Metrics**:<br>- **I ≈ 0.3** (vừa phải): 3 services đọc (Engine, Dashboard, Scoring), 1 service ghi (Auth).<br>- **ACs ưu tiên**: AC7 (Availability) - cần sẵn sàng cao cho login/profile. |
| **LearnerModelAggregate** | - LearnerModel (Root)<br>- SkillMasteryScore<br>- DiagnosticResult | - Score ∈ [0.0, 1.0]<br>- Each skill has 1 score/learner<br>- BKT state valid | **Vai trò**: **Trái tim AI** - lưu trạng thái thành thạo kỹ năng (ví dụ: Algebra: 0.85) (FR7, UC-04, UC-10).<br><br>**Quyết định**: Tách riêng thành **LearnerModel Service** (Golang).<br><br>**SOLID Rationale**:<br>- **SRP**: Cách ly logic AI - thay đổi BKT algorithm không ảnh hưởng profile.<br>- **DIP**: Adaptive Engine (Policy) phụ thuộc `LearnerModelRepository` Interface, không phải DB.<br><br>**Architecture Metrics**:<br>- **I ≈ 0.6** (bất ổn): Cập nhật liên tục, ít service phụ thuộc (chỉ Engine cần).<br>- **Deployability**: Cho phép deploy thuật toán AI mới độc lập (FR12, US8) - Blue/Green.<br>- **Performance**: Cache Redis cho read-heavy (Engine queries). |
| **ContentAggregate** | - Course (Root)<br>- Chapter<br>- ContentUnit<br>- MetadataTag<br>- Assessment | - Tag name unique<br>- Content version immutable<br>- Unit belongs to 1 Chapter | **Vai trò**: **Source of Truth** cho metadata (kỹ năng, độ khó, chủ đề) phục vụ AI (FR3, FR4, UC-05, UC-06).<br><br>**Quyết định**: Tách thành **Content Management Service** (Java/Spring Boot).<br><br>**SOLID Rationale**:<br>- **OCP**: Metadata mở rộng qua tagging (thêm tag mới), không sửa schema `ContentUnit`.<br>- **SRP**: Chỉ quản lý nội dung, không chứa logic scoring/feedback.<br><br>**Architecture Metrics**:<br>- **I ≈ 0** (rất ổn định): 4 services phụ thuộc (Engine, Feedback, Dashboard, Learner).<br>- **Caching Strategy**: CDN cho video/static, Redis cho metadata queries.<br>- **ACs ưu tiên**: AC7 (Reliability), AC2 (Scalability) - dữ liệu ít đổi, đọc nhiều. |
| **AdaptivePathAggregate** | - AdaptivePath (Root)<br>- PathNode<br>- RecommendationScore | - Path has ≥1 node<br>- Node references valid ContentUnit<br>- Score ∈ [0, 1] | **Vai trò**: Lưu kết quả lộ trình cá nhân hóa từ Adaptive Engine (FR7, UC-08).<br><br>**Quyết định**: **Ephemeral Aggregate** - tính toán on-the-fly, cache tạm 15 phút.<br><br>**SOLID Rationale**:<br>- **SRP**: Chỉ biểu diễn cấu trúc lộ trình (data), KHÔNG chứa logic tạo lộ trình (logic ở AdaptivePathGenerator Service).<br><br>**Architecture Metrics**:<br>- **I ≈ 1** (rất bất ổn): Không service nào phụ thuộc, chỉ Learner Dashboard đọc.<br>- **Storage Strategy**: Redis cache (TTL=15min), không persist DB (tính lại mỗi lần cần).<br>- **Performance**: AC3 - generate path < 200ms. |
| **UserManagementAggregate** | - User (Root)<br>- Role<br>- Permission<br>- AuditLog | - Email unique<br>- User has ≥1 Role<br>- Role has ≥1 Permission<br>- Audit immutable | **Vai trò**: Xác thực (AuthN) & phân quyền (RBAC - FR1, FR11, UC-01, UC-02, UC-17).<br><br>**Quyết định**: Tách thành **Auth Service** để tái sử dụng (có thể dùng cho nhiều hệ thống).<br><br>**SOLID Rationale**:<br>- **SRP**: Chỉ quản lý identity/security, không chứa business logic ITS.<br>- **ISP**: Tách interface `AuthenticationService` (login) và `AuthorizationService` (RBAC).<br><br>**Architecture Metrics**:<br>- **I ≈ 0.2** (ổn định): 5 services phụ thuộc (cần JWT validation), ít thay đổi.<br>- **Security**: AC6 - audit logs cho mọi thay đổi quyền, JWT with RS256.<br>- **ACs ưu tiên**: AC6 (Security), AC7 (Availability). |

---

##### Ví dụ Transaction Boundary

**Vai trò phân tích:**
- Minh họa cách quản lý giao dịch trong các Aggregate
- Giải thích nguyên tắc tách biệt và nhất quán dữ liệu
- Hướng dẫn thực hành tốt trong thiết kế hệ thống phân tán

**Nguyên tắc chính:**
1. Chỉ thực hiện giao dịch trong phạm vi một Aggregate
2. Sử dụng các sự kiện để đồng bộ hóa giữa các Aggregate
3. Đảm bảo tính nhất quán cuối cùng (Eventual Consistency)

**Ví dụ về cập nhật thông tin người học:**
- Cập nhật mục tiêu học tập chỉ diễn ra trong phạm vi LearnerAggregate
- Sử dụng sự kiện để thông báo các service khác về thay đổi

**Hành động khi cập nhật:**
- Thực hiện giao dịch trong phạm vi Aggregate Root
- Phát sinh sự kiện để các service khác có thể phản ứng
- Đảm bảo tính độc lập và linh hoạt của các service

---

#### B. Domain Services (Logic nghiệp vụ cốt lõi)

##### Khái niệm Domain Service

**Định nghĩa:**
- **Domain Service**: Nơi đặt logic nghiệp vụ **không thuộc về một Entity/Aggregate cụ thể**.
- **Đặc điểm**: Stateless, phụ thuộc vào **Abstraction** (Interface), dễ test và hoán đổi.
- **Vai trò kiến trúc**: Là **Policy Modules** trong Clean Architecture - chứa quy tắc nghiệp vụ cốt lõi, phải **ổn định** (I ≈ 0).

**Vai trò phân tích:**
- Cung cấp cơ chế tách biệt logic nghiệp vụ khỏi cấu trúc dữ liệu
- Hỗ trợ tính mở rộng và linh hoạt của hệ thống
- Tạo điều kiện cho việc kiểm thử và phát triển độc lập

**Khi nào cần Domain Service?**

| **Tình huống** | **Giải pháp** | **Ví dụ ITS** |
|---------------|--------------|---------------|
| Logic liên quan **≥2 Aggregates** | Tạo Domain Service | ScoringEngine cần Assessment + LearnerModel để tính score. |
| Logic **không có state** (pure function) | Tạo Domain Service | AdaptivePathGenerator - input: LearnerModel, output: Path (không lưu state). |
| Logic **cần hoán đổi** (swappable algorithms) | Tạo Domain Service + Interface | FeedbackGenerator - có thể thay Rule-based → NLP-based. |
| Logic **complex business rules** | Tạo Domain Service | RemediationEngine - quy tắc gợi ý bài học bù (nhiều điều kiện). |

**Khi không nên dùng Domain Service:**
- Logic thuộc về 1 Entity → Đặt trong Entity method
- Ví dụ: Cập nhật email nên ở trong lớp Learner, không cần service riêng

---

##### Bảng Chi Tiết Domain Services

| **Tên Domain Service** | **Input Aggregates** | **Output** | **Vai trò & Quyết định Kiến trúc** |
|----------------------|---------------------|------------|--------------------------------|
| **AdaptivePathGenerator** | - `LearnerModel` (Interface)<br>- `ContentMetadata` (Interface) | `AdaptivePath` | **Vai trò**: Tạo lộ trình học tập cá nhân hóa dựa trên điểm mạnh/yếu (FR7, US0, UC-08).<br><br>**Quyết định**: Đặt trong **Adaptive Engine Service** riêng (Golang) để dễ deploy thuật toán mới (FR12, AC1).<br><br>**SOLID Principles**:<br>- **SRP**: Chỉ tạo lộ trình, không quản lý data.<br>- **DIP**: Phụ thuộc `LearnerModelRepository` Interface, không phải PostgreSQL/MongoDB cụ thể.<br>- **OCP**: Thêm algorithm mới (ví dụ: Reinforcement Learning) bằng Strategy Pattern, không sửa code cũ.<br><br>**Testability**: Mock `LearnerModel` để test logic độc lập (no DB).<br><br>**Performance Target**: Generate path < 200ms (AC3).<br><br>**Deployability**: Blue/Green deployment - chạy V1 & V2 song song, A/B testing. |
| **ScoringEngine** | - `Assessment` (Interface)<br>- `SubmittedAnswer` | `AssessmentResult`<br>(score, feedback) | **Vai trò**: Chấm điểm tự động (MCQ, coding, essay) và cập nhật `SkillMasteryScore` (FR5, FR6, UC-10).<br><br>**Quyết định**: Có thể tích hợp ML model (BERT cho essay grading, unit test runner cho coding).<br><br>**SOLID Principles**:<br>- **SRP**: Chỉ xử lý scoring logic.<br>- **DIP**: Phụ thuộc `AssessmentRepository` Interface.<br>- **OCP**: Hỗ trợ nhiều loại assessment (Quiz, Coding, Essay) qua polymorphism.<br><br>**Deployability**: Hoán đổi ML model dễ dàng (FR12, US8) - load model từ S3/Kafka.<br><br>**Performance Target**: < 1s cho grading (AC3).<br><br>**Architecture Note**: Event-driven - emit `SubmissionCompleted` event sau khi score → LearnerModel Service cập nhật async. |
| **FeedbackGenerator** | - `Assessment` (Interface)<br>- `ErrorPattern` (Interface) | `Feedback`<br>(hints, explanation) | **Vai trò**: Tạo phản hồi tức thì, hints, remediation suggestions (FR6, US1, UC-10, UC-11).<br><br>**Quyết định**: Tích hợp NLP để tạo giải thích tự nhiên (OpenAI API hoặc local LLM).<br><br>**SOLID Principles**:<br>- **SRP**: Chỉ tạo feedback, không chấm điểm.<br>- **ISP**: Tách interfaces:<br>  - `HintGenerator` (gợi ý ngắn)<br>  - `ExplanationGenerator` (giải thích chi tiết)<br>  - `RemediationSuggester` (gợi ý bài học bù)<br>  → Client (UI) chỉ phụ thuộc cái cần dùng.<br><br>**Performance Target**: Hiển thị < 500ms (AC3).<br><br>**Caching**: Cache feedback patterns cho common errors (Redis). |
| **RemediationEngine** | - `LearnerModel` (Interface)<br>- `ContentMetadata` (Interface) | List of `ContentUnit`<br>(bài học bù) | **Vai trò**: Phát hiện kỹ năng yếu và gợi ý bài học bổ sung (FR6, FR7, UC-11).<br><br>**Business Rules**:<br>- If skill mastery < 0.6 → recommend easier content<br>- If repeated errors → recommend tutorial videos<br>- If forgotten (last practice > 7 days) → spaced repetition<br><br>**SOLID Principles**:<br>- **SRP**: Chỉ tạo gợi ý, không cập nhật LearnerModel.<br>- **DIP**: Phụ thuộc interfaces, không phải DB.<br><br>**Integration**: Call AdaptiveEngine API để lấy recommended content. |

---

##### Ví dụ Code: Domain Service (Golang)

**AdaptivePathGenerator (Policy Module)**

```go
package application

// Domain Service - Stateless, depends on Interfaces
type AdaptivePathGenerator struct {
    learnerModelRepo LearnerModelRepository // Interface (DIP)
    contentRepo      ContentRepository      // Interface (DIP)
}

// Constructor (Dependency Injection)
func NewAdaptivePathGenerator(
    learnerRepo LearnerModelRepository,
    contentRepo ContentRepository,
) *AdaptivePathGenerator {
    return &AdaptivePathGenerator{
        learnerModelRepo: learnerRepo,
        contentRepo:      contentRepo,
    }
}

// Generate Path (Pure business logic - TESTABLE)
func (g *AdaptivePathGenerator) GeneratePath(
    ctx context.Context,
    learnerID string,
) (*AdaptivePath, error) {
    // 1. Get learner's current skill state (via Interface)
    learnerModel, err := g.learnerModelRepo.FindByID(ctx, learnerID)
    if err != nil {
        return nil, err
    }
    
    // 2. Find weak skills (business logic)
    weakSkills := g.identifyWeakSkills(learnerModel) // mastery < 0.6
    
    // 3. Get available content for weak skills (via Interface)
    availableContent, _ := g.contentRepo.FindBySkills(ctx, weakSkills)
    
    // 4. Apply adaptive algorithm (Strategy Pattern - OCP)
    path := g.applyAdaptiveAlgorithm(learnerModel, availableContent)
    
    return path, nil
}

// Pure function - easy to test
func (g *AdaptivePathGenerator) identifyWeakSkills(
    model *LearnerModel,
) []string {
    var weak []string
    for skill, mastery := range model.SkillScores {
        if mastery < 0.6 { // Business rule
            weak = append(weak, skill)
        }
    }
    return weak
}

// Swappable algorithm (OCP)
func (g *AdaptivePathGenerator) applyAdaptiveAlgorithm(
    model *LearnerModel,
    content []*ContentUnit,
) *AdaptivePath {
    // V1: Rule-based sorting by difficulty
    // V2: ML-based ranking (can be swapped via Strategy Pattern)
    // ...
}
```

**Unit Test (NO DATABASE)**

```go
package application_test

func TestAdaptivePathGenerator_WeakSkills(t *testing.T) {
    // Mock repositories (no real DB)
    mockLearnerRepo := &MockLearnerModelRepo{
        FindByIDFunc: func(ctx context.Context, id string) (*LearnerModel, error) {
            return &LearnerModel{
                LearnerId: id,
                SkillScores: map[string]float64{
                    "Algebra":  0.3, // Weak
                    "Geometry": 0.9, // Strong
                },
            }, nil
        },
    }
    
    mockContentRepo := &MockContentRepo{
        FindBySkillsFunc: func(ctx context.Context, skills []string) ([]*ContentUnit, error) {
            return []*ContentUnit{
                {UnitID: "algebra-101", Difficulty: "easy"},
            }, nil
        },
    }
    
    // Create service with mocks (DIP in action)
    generator := NewAdaptivePathGenerator(mockLearnerRepo, mockContentRepo)
    
    // Test business logic WITHOUT database
    path, err := generator.GeneratePath(context.Background(), "learner-123")
    
    assert.NoError(t, err)
    assert.Equal(t, 1, len(path.Nodes))
    assert.Equal(t, "algebra-101", path.Nodes[0].ContentID)
    
    // Test passed in < 1ms (no DB calls)
}
```

**Lợi ích:**
- ✅ Test tốc độ cao (ms thay vì giây với DB)
- ✅ No flaky tests (không phụ thuộc DB state)
- ✅ Easy to debug (pure logic, no side effects)
- ✅ Easy to swap DB (Postgres → MongoDB) - chỉ sửa Infrastructure layer

---

#### C. Ánh xạ Aggregate → Microservice/Component

Bảng dưới cho thấy cách Domain Model dẫn đến quyết định kiến trúc Microservices:

| Aggregate/Service | Lý do Tách Service | Chỉ số Bất ổn (I) | ACs ưu tiên |
|-----------------------|--------------------|-------------------|-------------|
| LearnerAggregate → Learner Service | CRUD profile, ít thay đổi nhưng cần sẵn sàng cao | I ≈ 0.3 | Availability |
| LearnerModelAggregate → LearnerModel Service | Cập nhật liên tục, tính toán AI nặng, cần deploy riêng | I ≈ 0.6 | Modularity, Deployability |
| ContentAggregate → Content Management Service | Dữ liệu ổn định, nhiều service phụ thuộc | I ≈ 0 | Reliability, Scalability |
| AdaptivePathGenerator → Adaptive Engine Service | Logic AI cốt lõi, cần hoán đổi thuật toán | I ≈ 0 | Extensibility, Deployability |
| UserManagementAggregate → Auth Service | Tái sử dụng, bảo mật cao | I ≈ 0.2 | Security |

**Giải thích Chỉ số I (Instability)**:
- **I = 0**: Rất ổn định (nhiều service phụ thuộc, ít thay đổi) → Content, Policy Modules
- **I → 1**: Bất ổn (ít phụ thuộc, thay đổi nhiều) → LearnerModel (cập nhật liên tục)
- **Nguyên tắc**: Policy (I≈0) không nên phụ thuộc vào Detail (I→1) → Dependency Inversion Principle
