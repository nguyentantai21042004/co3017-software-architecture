# Trade-off Analysis (Phân tích Đánh đổi)

## Nguyên tắc

> **"Mọi thứ đều là sự đánh đổi"** - Nguyên tắc vàng trong kiến trúc phần mềm

Mục tiêu của bước này là đưa ra quyết định **chấp nhận rủi ro ở đâu** và **tối ưu hóa ở đâu** để đạt được **"kiến trúc ít tệ nhất"** (_the least worst architecture_) phù hợp với ngữ cảnh ITS.

---

## Các Xung đột Architecture Characteristics

### 1. Scalability (AC2) & Modularity (AC1) ↔ Simplicity

| **Phân tích Đánh đổi** | **Quyết định và Lý do** |
|------------------------|-------------------------|
| Các phong cách kiến trúc tối ưu hóa Scalability (ví dụ: **Microservices**) có độ phức tạp cao hơn về phát triển, vận hành, và giám sát so với **Monolithic**. Độ phức tạp cao làm giảm Simplicity. | ✅ **Ưu tiên: Scalability & Modularity**<br><br>Chúng ta chấp nhận **Độ phức tạp Vận hành** (Complexity) cao hơn vì **Modularity** là bắt buộc để thực hiện **Live AI Model Swapping** (FR12), vốn là yêu cầu cốt lõi. |

---

### 2. Performance (AC3) ↔ Modularity/Coupling

| **Phân tích Đánh đổi** | **Quyết định và Lý do** |
|------------------------|-------------------------|
| Việc phân chia quá mịn (**Too Fine-Grained Components**) để đạt Modularity có thể dẫn đến quá nhiều lời gọi mạng (network calls), làm tăng độ trễ (Latency) và ảnh hưởng tiêu cực đến Performance. | ⚖️ **Ưu tiên: Cân bằng (Balanced Granularity)**<br><br>Phải đảm bảo các chức năng nghiệp vụ **liên quan chặt chẽ** (**Functional Cohesion**) được đóng gói trong cùng một Service (ví dụ: Logic Chấm điểm và Cập nhật Model) để tránh giao tiếp mạng không cần thiết, duy trì **Latency ≤ 500ms**. |

---

### 3. Security (AC6) ↔ Performance (AC3)

| **Phân tích Đánh đổi** | **Quyết định và Lý do** |
|------------------------|-------------------------|
| Tăng cường bảo mật (ví dụ: mã hóa dữ liệu người học (PII) khi truyền tải (**in transit**) và khi lưu trữ (**at rest**), hoặc thêm lớp xác thực giữa các service) sẽ làm tăng chi phí xử lý và độ trễ. | ✅ **Ưu tiên: Security (Data Protection)**<br><br>Chúng ta chấp nhận độ trễ nhỏ **có thể chấp nhận được** do mã hóa (TLS/HTTPS) để bảo vệ **Learner Model** (FR2) và PII. **Bảo mật là không thể thương lượng**. |

---

### 4. Testability (AC4) ↔ Development Cost

| **Phân tích Đánh đổi** | **Quyết định và Lý do** |
|------------------------|-------------------------|
| Áp dụng **Clean/Hexagonal Architecture** để đạt Testability cao (tuân thủ **DIP/SRP**) yêu cầu cấu trúc mã nguồn phức tạp hơn, dẫn đến chi phí phát triển ban đầu cao hơn và đường cong học tập khó hơn cho đội ngũ. | ✅ **Ưu tiên: Testability**<br><br>Chi phí ban đầu cao hơn được đánh đổi với **chi phí bảo trì** (Maintainability) thấp hơn về lâu dài và **độ tin cậy cao hơn** cho các thuật toán AI (FR7). Đây là một **quyết định chiến lược** cho tuổi thọ hệ thống. |

---

## Bảng Tổng hợp Trade-offs

| **Xung đột ACs** | **Quyết định** | **AC được Ưu tiên** | **AC bị Hy sinh** | **Lý do Chính** |
|------------------|----------------|---------------------|-------------------|-----------------|
| Scalability & Modularity ↔ Simplicity | Ưu tiên Scalability & Modularity | AC1, AC2 | Simplicity | Live AI Model Swapping (FR12) là yêu cầu cốt lõi |
| Performance ↔ Modularity | Cân bằng (Balanced Granularity) | AC3, AC1 | - | Duy trì latency ≤ 500ms bằng Functional Cohesion |
| Security ↔ Performance | Ưu tiên Security | AC6 | AC3 (chấp nhận +50-100ms) | Bảo vệ PII và LearnerModel không thể thương lượng |
| Testability ↔ Development Cost | Ưu tiên Testability | AC4 | - (chi phí ban đầu cao) | Độ tin cậy thuật toán AI và chi phí bảo trì dài hạn |
