\section{Góc Nhìn Kiến Trúc}

\indentpar \indentpar Chương này trình bày chi tiết kiến trúc của hệ thống ITS thông qua các góc nhìn (views) khác nhau, tuân theo mô hình 4+1 View Model. Mỗi góc nhìn làm rõ một khía cạnh của hệ thống---từ cấu trúc tổ chức mã nguồn đến hành vi và triển khai---giúp các bên liên quan (stakeholders) có một cái nhìn thống nhất và toàn diện.

Nếu Chương 3 tập trung vào việc ``chọn kiến trúc nào'' và ``quyết định ra sao'', thì Chương 4 trả lời câu hỏi ``kiến trúc đó trông như thế nào trong thực tế?''

\subsection{Module View}

\indentpar \indentpar Bắt đầu với Module View, góc nhìn mô tả cách hệ thống được phân rã và tổ chức code nội bộ theo Clean Architecture và Domain-Driven Design. 
Module View (Góc nhìn Module) mô tả sự phân rã của hệ thống thành các thành phần (components) và các module con, cùng mối quan hệ giữa chúng. Góc nhìn này trả lời cho hai câu hỏi cốt lõi: \textit{``Hệ thống được tổ chức như thế nào?''} và \textit{``Các phần code bên trong được cấu trúc ra sao?''}

Module View đặc biệt quan trọng vì nó thể hiện cách các quyết định trong ADR-1 \textrightarrow{} ADR-4 (Polyglot, Clean Architecture, Repository Pattern) được hiện thực hóa ở cấp mã nguồn, giúp đạt được các đặc tính kiến trúc quan trọng nhất của ITS: 
\textbf{AC1 -- Modularity}, \textbf{AC4 -- Testability}, và \textbf{AC7 -- Maintainability}.

\subsubsection{Phân rã Hệ thống}

\indentpar \indentpar Hệ thống ITS được thiết kế theo phong cách \textbf{Hybrid Microservices + Event-Driven Architecture}. Việc phân rã hệ thống \textbf{(System Decomposition)} dựa trên Bounded Contexts của Domain-Driven Design (DDD).

\textbf{Lưu ý về phạm vi MVP:} Trong giai đoạn hiện tại (MVP), chúng tôi tập trung hiện thực các service cốt lõi liên quan trực tiếp đến luồng học tập thích ứng (Content, Scoring, Learner Model, Adaptive Engine). Các service hỗ trợ như \textbf{User Management} và \textbf{Auth Service} được mô tả trong kiến trúc đích (Target Architecture) nhưng chưa được tách thành microservice riêng biệt trong phiên bản code hiện tại; thay vào đó, các chức năng này được giả lập hoặc xử lý đơn giản để ưu tiên kiểm chứng logic nghiệp vụ chính.

\vspace{1em}

\begin{figure}[H]
\centering
{\includegraphics[width=0.95\textwidth]{images/system_decomposition.png}}
\caption{Sơ đồ phân rã module cấp cao của hệ thống ITS}
\label{fig:system-decomposition}
\end{figure}

Phân rã này cũng thể hiện rõ \textbf{``Bounded Contexts''} của DDD, cho phép mỗi service có thể triển khai, kiểm thử và mở rộng độc lập mà vẫn phối hợp thông qua event bus (RabbitMQ theo ADR-8).

\subsubsection{Cấu trúc các Tầng}

\indentpar \indentpar Để hiện thực hóa ADR-3 (Clean/Hexagonal Architecture), tất cả service (Java và Go) đều tuân thủ kiến trúc phân tầng đồng tâm. Cách tiếp cận này tách biệt rõ Business Logic và Infrastructure, qua đó bảo đảm khả năng kiểm thử và bảo trì lâu dài.

\noindent\textbf{Quy tắc Phụ thuộc (Dependency Rule)}
\begin{itemize}[leftmargin=1.5em]
    \item Luồng phụ thuộc của mã nguồn luôn đi từ vòng ngoài vào vòng trong
    \item Tầng trung tâm (Domain, Application) không phụ thuộc vào Database, Framework hay UI
    \item Giao tiếp từ trong ra ngoài phải thông qua các interface theo nguyên tắc Dependency Inversion
\end{itemize}

\vspace{1em}

\begin{figure}[H]
\centering
\includegraphics[width=0.55\textwidth]{images/clean-architecture-layers.png}
\caption{Sơ đồ tầng Clean Architecture với Dependency Rule}
\label{fig:clean-architecture-layers}
\end{figure}

\renewcommand{\arraystretch}{1.3}
\begin{table}[H]
\centering
\small
\begin{tabularx}{\textwidth}{|>{\centering\arraybackslash}p{2.5cm}|>{\raggedright\arraybackslash}X|>{\raggedright\arraybackslash}p{3.5cm}|>{\centering\arraybackslash}X|}
\hline
\textbf{Tầng} & \textbf{Trách nhiệm} & \textbf{Quy tắc phụ thuộc} & \textbf{Ví dụ cụ thể trong ITS} \\
\hline
Domain & Định nghĩa các khái niệm cốt lõi của nghiệp vụ (Entities, Value Objects, Domain Events nội bộ) cùng các quy tắc bất biến. & Hoàn toàn độc lập; không tham chiếu ra ngoài mà chỉ phơi bày interface để tầng khác hiện thực. & \begin{tabular}{@{}c@{}}\texttt{Learner.java}\\\texttt{Course.java}\\\texttt{SkillMasteryScore.java}\\\texttt{LearnerRepository.java}\end{tabular} \\
\hline
Application & Đóng gói các Use Case, điều phối tương tác giữa Domain qua các Input/Output Port và thực thi kịch bản nghiệp vụ. & Chỉ được phép phụ thuộc vào Domain; mọi phụ thuộc khác phải đi qua port. & \begin{tabular}{@{}c@{}}\texttt{CreateNewCourseUseCase.java}\\\texttt{UpdateSkillMasteryUseCase.java}\\\texttt{SkillMasteryDTO.java}\end{tabular} \\
\hline
Interface Adapters & Chuyển đổi dữ liệu, hiện thực các port, gom/chiếu dữ liệu giữa Application với bên ngoài (HTTP, DB, MQ). & Phụ thuộc ngược vào Application và Domain để triển khai các adapter cụ thể. & \begin{tabular}{@{}c@{}}\texttt{LearnerController.java}\\\texttt{PostgresLearnerRepository.java}\end{tabular} \\
\hline
Infrastructure & Cung cấp chi tiết kỹ thuật: framework, driver, cấu hình triển khai, message broker, scheduler. & Phụ thuộc vào Interface Adapters để cung ứng tài nguyên và wiring hạ tầng. & \begin{tabular}{@{}c@{}}Spring Boot\\Gin\\PostgreSQL driver\\RabbitMQ client\end{tabular} \\
\hline
\end{tabularx}
\caption{Vai trò và quy tắc phụ thuộc của các tầng Clean Architecture}
\label{tab:clean-architecture-layers}
\end{table}
\renewcommand{\arraystretch}{1.0}

\subsubsection{Cấu trúc Gói}

\indentpar \indentpar Việc chuẩn hóa, minh họa cách tổ chức mã nguồn thực tế (Java \& Go) sao cho phù hợp với Clean Architecture và Polyglot Strategy (ADR-1) nhằm đảm bảo tính nhất quán giữa các ngôn ngữ, đồng thời giúp đội ngũ phát triển dễ dàng định hướng khi làm việc với các service khác nhau.

\noindent\textbf{a. Service Java (Content Service)}

\noindent\textbf{Cấu trúc thư mục}
\begin{center}
\begin{minipage}{0.95\textwidth}
\begin{verbatim}
src/main/java/co3017/microservices/content_service/
|-- adapter/
|   `-- http/                # REST controllers, DTOs, response builders
|-- config/                  # Spring Boot entry point, cross-cutting config
|-- mappers/                 # Domain <-> Persistence transformers
|-- models/                  # Domain entities & value objects
|-- repository/              # Ports (interfaces) & Postgres adapters
|   `-- postgresql/
|       |-- entity/          # JPA entities
|       |-- mapper/          # Persistence-specific mappers
|       |-- specification/   # Query specifications (criteria builders)
|       `-- springdata...    # Spring Data repositories + adapters
`-- usecase/                 # Application layer contracts & services
    |-- service/            # Use case implementations (business orchestration)
    `-- types/              # Commands, queries, DTOs cho use cases

src/main/resources/          # Infrastructure config (YAML, SQL migrations)
\end{verbatim}
\end{minipage}
\end{center}

\noindent\textbf{Giải thích cấu trúc}
\begin{itemize}[leftmargin=1.2em]
    \item \textbf{Domain Layer} (\texttt{models/}, \texttt{repository/*.java}): chứa Aggregate Root, Value Object (\texttt{Course}, \texttt{ContentUnit}, \texttt{MetadataTag}). Các lớp thuần Java, không phụ thuộc framework; \texttt{repository/} định nghĩa các port như \texttt{CourseRepository}, \texttt{ContentVersionRepository}
    \item \textbf{Application Layer} (\texttt{usecase/}): gồm interface \texttt{CourseUseCase}, \texttt{ContentUnitUseCase} và implementation \texttt{CourseService}. \texttt{usecase/types/} gom các command/query (\texttt{CreateCourseCommand}, \texttt{CourseSearchCriteria}) và DTO phản hồi (\texttt{CoursePageResult})
    \item \textbf{Interface Adapters Layer} (\texttt{adapter/http}, \texttt{mappers/}): controller REST (\texttt{CourseController}) và DTO request/response chuyển đổi HTTP payload \(\rightarrow\) \texttt{usecase.types}. Các mapper nối domain với entity persistence, không phụ thuộc annotation đặc thù
    \item \textbf{Infrastructure Layer} (\texttt{repository/postgresql}, \texttt{config/}, \texttt{resources/}): hiện thực port bằng Spring Data JPA (\texttt{JpaCourseRepository} \(\leftrightarrow\) \texttt{SpringDataCourseRepository}), cấu hình entry point (\texttt{ContentServiceApplication}, \texttt{CorsConfig}), và tài nguyên \texttt{application.yml}, script SQL
\end{itemize}

\noindent\textbf{Tuân thủ Dependency Rule.}
\begin{itemize}[leftmargin=1.2em]
    \item \texttt{models/} và \texttt{repository/*.java} (domain) hoàn toàn độc lập, không biết gì về Spring, JPA hay HTTP
    \item \texttt{usecase/} chỉ phụ thuộc domain interface, điều phối business logic thông qua port mà không quan tâm implementation cụ thể
    \item \texttt{adapter/} và \texttt{repository/postgresql}, \texttt{config/} hiện thực các interface đó, phụ thuộc ngược vào \texttt{usecase/} nhưng không kéo domain vào vòng phụ thuộc
\end{itemize}

Cấu trúc này cho phép đội ngũ áp dụng blueprint chung khi dịch sang Go, đảm bảo tính nhất quán về phân tầng và Dependency Rule giữa các ngôn ngữ trong hệ thống polyglot.

\noindent\textbf{b. Service Go (Learner Model Service)}

\noindent\textbf{Cấu trúc thư mục}
\begin{center}
\begin{minipage}{0.95\textwidth}
\begin{verbatim}
/Users/tantai/Workspaces/smap/smap-api/
|-- domain/
|   |-- internal/models/
|   |-- internal/dbmodels/
|   |-- internal/auth/ (uc_interface.go, uc_types.go, uc_errors.go, repo_interface.go)
|   |-- internal/user/ (uc_interface.go, uc_types.go, uc_errors.go, repo_interface.go)
|   |-- internal/role/ (uc_interface.go, uc_types.go, uc_errors.go, repo_interface.go)
|   `-- internal/session/ (uc_interface.go, uc_types.go, uc_errors.go, repo_interface.go)
|-- application/
|   |-- internal/auth/usecase/
|   |-- internal/user/usecase/
|   |-- internal/role/usecase/
|   |-- internal/session/usecase/
|   `-- internal/core/smtp/usecase/
|-- adapters/
|   |-- internal/httpserver/
|   |   |-- handler.go
|   |   |-- httpserver.go
|   |   `-- new.go
|   |-- internal/middleware/
|   |-- internal/auth/delivery/http/
|   |-- internal/auth/delivery/rabbitmq/
|   |-- internal/user/delivery/http/
|   |-- internal/role/delivery/http/
|   |-- internal/session/repository/mongo/
|   |-- internal/user/repository/mongo/
|   `-- internal/role/repository/mongo/
`-- infrastructure/
    |-- cmd/api/main.go
    |-- cmd/consumer/main.go
    |-- config/
    |-- internal/appconfig/mongo/
    |-- internal/appconfig/oauth/
    |-- internal/consumer/
    |-- pkg/
    |   `-- log/, redis/, rabbitmq/, mongo/, email/, discord/
    |   `-- scope/, otp/, response/, paginator/, errors/, util/, ...
    `-- deployment/, docker-compose.yml, Jenkinsfile, Makefile
\end{verbatim}
\end{minipage}
\end{center}

\noindent\textbf{Giải thích cấu trúc}
\begin{itemize}[leftmargin=1.2em]
    \item \textbf{Domain Layer} (\texttt{domain/}): chứa entity thuần (\texttt{internal/models}, \texttt{internal/dbmodels}) và các contract (interface, DTO, error) của từng bounded context \texttt{internal/\{auth,user,role,session\}}. Hoàn toàn không phụ thuộc Gin, Mongo driver hay adapter cụ thể
    \item \textbf{Application Layer} (\texttt{application/}): triển khai use case (\texttt{internal/\{auth,user,role,session\}/usecase}) và dịch vụ cốt lõi (\texttt{internal/core/smtp/usecase}). Các package này sử dụng interface từ \texttt{domain/}, điều phối giữa nhau (ví dụ \texttt{auth} gọi \texttt{userUC}, \texttt{roleUC}, \texttt{sessionUC}) và phát sự kiện RabbitMQ
    \item \textbf{Interface Adapters Layer} (\texttt{adapters/}): gồm entry adapter (Gin handler, RabbitMQ producer) và data adapter (Mongo repository). \texttt{internal/httpserver}, \texttt{internal/middleware} định nghĩa router, middleware; \texttt{internal/\{module\}/delivery} ánh xạ request/response, gửi cảnh báo Discord; \texttt{internal/\{module\}/repository/mongo} hiện thực repository interface bằng MongoDB
    \item \textbf{Infrastructure Layer} (\texttt{infrastructure/}): tập trung file khởi động, cấu hình, wiring và tiện ích dùng chung. \texttt{cmd/api/main.go}, \texttt{cmd/consumer/main.go} load config, khởi tạo logger/encrypter, kết nối Mongo/Redis/RabbitMQ, dựng HTTP server hoặc consumer. \texttt{config/}, \texttt{internal/appconfig/*}, \texttt{pkg/*} cung cấp adapter tái sử dụng (logger Zap, Redis client, Discord webhook, SMTP, i18n, paginator, OTP, response). Các artifact triển khai (deployment, Docker Compose, Jenkinsfile, Makefile) cũng nằm tại đây
\end{itemize}

Cách trình bày này giúp đội ngũ xem kiến trúc Go hiện tại dưới cùng một blueprint với các service khác (Java hoặc Go) mà ADR-1 đề ra, đồng thời duy trì biên rõ ràng để mở rộng hoặc refactor.