\section{Áp dụng các Nguyên tắc SOLID}

\indentpar \indentpar Chương này mô tả chi tiết cách 5 nguyên tắc SOLID được áp dụng trong toàn bộ hệ thống ITS. Việc tuân thủ này là nền tảng kỹ thuật bắt buộc để đạt được các Đặc tính Kiến trúc (ACs) đã ưu tiên, đặc biệt là AC1: Modularity, AC4: Testability, và AC7: Maintainability.

\subsection{Nguyên tắc Trách nhiệm Đơn lẻ (Single Responsibility Principle - SRP)}

\subsubsection{Tổng quan Nguyên tắc}

\noindent Định nghĩa: ``Một lớp (class) chỉ nên có một, và chỉ một, lý do để thay đổi.''

\noindent Áp dụng trong ITS: Nguyên tắc này được áp dụng ở nhiều cấp độ:

\begin{itemize}[leftmargin=1.5em]
    \item Cấp độ Dịch vụ (Service): Mỗi microservice sở hữu một miền nghiệp vụ (Bounded Context) duy nhất. Ví dụ, \texttt{UserManagementService} chỉ có lý do thay đổi khi nghiệp vụ quản lý người dùng thay đổi; nó không thay đổi khi thuật toán chấm điểm (Scoring) thay đổi
    \item Cấp độ Lớp (Class): Mỗi lớp chỉ có một trách nhiệm. Ví dụ, \texttt{ScoringUseCase} chịu trách nhiệm điều phối nghiệp vụ chấm điểm, trong khi \texttt{ScoringRepository} chịu trách nhiệm lưu trữ kết quả
    \item Cấp độ Phương thức (Method): Mỗi phương thức thực hiện tốt một việc duy nhất
\end{itemize}

\subsubsection{Ví dụ Triển khai}

\indentpar \indentpar Như được minh họa trong tài liệu SOLID principles, chúng ta đã tách biệt rõ ràng các trách nhiệm.

\noindent Ví dụ 1: Tách biệt Service (Vi phạm và Sửa lỗi)

\noindent\textit{Trước SRP (Xấu)}: Một \texttt{LearnerModelService} ``thần thánh'' (god service) làm tất cả mọi thứ.

\begin{lstlisting}[language=Java, caption={Vi phạm SRP - God Service}]
// [XAU] Vi pham SRP, co 3 ly do de thay doi
@Service
public class LearnerModelService {
    // Trach nhiem 1: Quan ly Profile
    public Learner createProfile(String name, String email) { /* ... */ }
    
    // Trach nhiem 2: Tinh toan Skill
    public void updateSkillMastery(Long learnerId, String skill, double score) {
        // Logic AI phuc tap
    }
    
    // Trach nhiem 3: Tao Bao cao
    public Report generateLearningReport(Long learnerId) { /* ... */ }
}
\end{lstlisting}

\noindent\textit{Sau SRP (Tốt)}: Tách thành 3 microservice riêng biệt, mỗi service có một trách nhiệm duy nhất.

\begin{lstlisting}[language=Java, caption={Tuân thủ SRP - Tách biệt Service}]
// GOOD: Separate responsibilities

// Service 1: UserManagementService (Java)
@Service
public class LearnerProfileService {
    public LearnerProfile createProfile(String name, String email) { /* ... */ }
}

// Service 2: LearnerModelService (Go)
package application
type UpdateSkillMasteryUseCase struct { /* ... */ }
func (uc *UpdateSkillMasteryUseCase) Execute(...) error {
    // Only skill mastery update logic
}

// Service 3: ReportingService (Java)
@Service
public class LearningAnalyticsService {
    public Report generateReport(Long learnerId) { /* ... */ }
}
\end{lstlisting}

\noindent Ví dụ 2: Tách biệt Tầng trong Service (Clean Architecture)

\noindent\textit{Trước SRP (Xấu)}: Controller (tầng Web) xử lý luôn cả logic nghiệp vụ và truy cập CSDL.

\begin{lstlisting}[language=Go, caption={Vi phạm SRP - Controller làm tất cả}]
// BAD: Controller (Web layer) does everything
type QuizController struct {
    db *sql.DB
}

func (c *QuizController) SubmitAnswer(ctx *gin.Context) {
    // ... (Responsibility 1: Handle HTTP)
    
    // ... (Responsibility 2: Business logic)
    score := c.calculateScore(req.Answer) 
    
    // ... (Responsibility 3: Access CSDL)
    _, err := c.db.Exec("INSERT ...", req.UserID, score)
    
    ctx.JSON(200, gin.H{"score": score})
}
\end{lstlisting}

\noindent\textit{Sau SRP (Tốt)}: Tách biệt theo các tầng của Clean Architecture.

\begin{lstlisting}[language=Go, caption={Tuân thủ SRP - Tách theo tầng}]
// GOOD: Separate responsibilities by layer

// Controller (Web layer) - Only handle HTTP
type ScoringController struct {
    useCase *application.ScoringUseCase
}
func (c *ScoringController) SubmitAnswer(ctx *gin.Context) {
    // Only delegate to UseCase
    result, err := c.useCase.Execute(...)
    ctx.JSON(200, toDTO(result))
}

// UseCase (Application layer) - Only business logic
package application
type ScoringUseCase struct {
    repository domain.ScoreRepository // Depends on interface (DIP)
}
func (uc *ScoringUseCase) Execute(...) (*ScoreResult, error) {
    // Only business logic
    score := uc.calculateScore(req.Answer)
    
    // Delegate storage to Repository
    uc.repository.Save(ctx, score)
}

// Repository (Infrastructure layer) - Only access CSDL
package infrastructure
type PostgresScoreRepository struct {
    db *sql.DB
}
func (r *PostgresScoreRepository) Save(...) error {
    // Only access CSDL
    _, err := r.db.ExecContext(...)
    return err
}
\end{lstlisting}

\subsubsection{Checklist Xác minh}

\begin{itemize}[leftmargin=1.5em]
    \item Mỗi microservice có một Bounded Context nghiệp vụ rõ ràng
    \item Các lớp (class) chỉ có một lý do duy nhất để thay đổi (ví dụ: UseCase thay đổi khi nghiệp vụ thay đổi, Repository thay đổi khi CSDL thay đổi)
    \item Các phương thức (method) được giữ ngắn gọn (dưới 20 dòng) và tập trung
    \item Không có ``god class'' (lớp thần thánh) hoặc ``utility class'' (lớp tiện ích chứa rác)
\end{itemize}

\subsection{Nguyên tắc Đóng/Mở (Open/Closed Principle - OCP)}

\subsubsection{Chiến lược Triển khai}

\noindent Định nghĩa: ``Các thực thể phần mềm (lớp, module, hàm) nên được mở để mở rộng, nhưng đóng để sửa đổi.''

\noindent Chiến lược: Chúng ta đạt được OCP bằng cách phụ thuộc vào abstractions (interfaces). Các ``policy'' (chính sách) cấp cao được đóng, nhưng chúng ta có thể thêm các ``plugin'' (triển khai) mới để mở rộng hành vi.

\noindent Mẫu Thiết kế sử dụng:
\begin{itemize}[leftmargin=1.5em]
    \item Strategy Pattern: Dùng cho các thuật toán có thể thay thế (ví dụ: thuật toán chấm điểm, thuật toán gợi ý)
    \item Dependency Injection: Dùng để ``tiêm'' các chiến lược (strategy) khác nhau vào lúc runtime
\end{itemize}

\subsubsection{Ví dụ Code}

\indentpar \indentpar Đây là ví dụ quan trọng nhất để đáp ứng FR12: Live AI Model Swapping và được minh họa chi tiết trong tài liệu SOLID principles.

\noindent Ví dụ: Chiến lược Gợi ý Mở rộng (Strategy Pattern)

\noindent\textit{Trước OCP (Xấu)}: Dùng if/else hoặc switch/case. Để thêm một loại gợi ý mới, bạn bắt buộc phải sửa đổi hàm \texttt{GenerateHint}.

\begin{lstlisting}[language=Go, caption={Vi phạm OCP - Đóng để mở rộng}]
// BAD: Closed for extension. Must modify code when adding new type.
type HintGenerator struct{}

func (h *HintGenerator) GenerateHint(hintType string, ...) string {
    if hintType == "syntax" {
        // ...
    } else if hintType == "concept" {
        // ...
    }
    // Must modify this file to add "example"
    return "No hint available"
}
\end{lstlisting}

\noindent\textit{Sau OCP (Tốt)}: Sử dụng interface (chiến lược). Code lõi được đóng để sửa đổi.

\begin{lstlisting}[language=Go, caption={Tuân thủ OCP - Mở để mở rộng}]
// GOOD: Open for extension.

// Interface (Abstraction) - Closed for modification
type HintStrategy interface {
    Generate(context Context) string
}

// Implementation 1 - Open for extension
type SyntaxHintStrategy struct{}
func (s *SyntaxHintStrategy) Generate(ctx Context) string { /*...*/ }

// Implementation 2 - Open for extension
type ConceptHintStrategy struct{}
func (c *ConceptHintStrategy) Generate(ctx Context) string { /*...*/ }

// Implementation 3 (NEW) - Add new type without modifying existing code
type ExampleHintStrategy struct{}
func (e *ExampleHintStrategy) Generate(ctx Context) string { /*...*/ }

// Use Case (Core logic) - Closed for modification
type GenerateHintUseCase struct {
    strategy HintStrategy // Depends on interface
}
func (uc *GenerateHintUseCase) Execute(ctx Context) string {
    // Only call interface. Don't know which type.
    return uc.strategy.Generate(ctx)
}
\end{lstlisting}

\subsection{Nguyên tắc Thay thế Liskov (Liskov Substitution Principle - LSP)}

\subsubsection{Thiết kế Kế thừa}

\noindent Định nghĩa: ``Các đối tượng của lớp con phải có thể thay thế được cho các đối tượng của lớp cha mà không làm thay đổi tính đúng đắn của chương trình.''

\noindent Áp dụng trong ITS: Chúng ta đảm bảo LSP bằng cách tuân thủ ``hợp đồng'' (contract) của interface hoặc lớp cha. Các lớp con có thể mở rộng hành vi, nhưng không được vi phạm các giả định của lớp cha.

\noindent Ví dụ trong ITS:
\begin{itemize}[leftmargin=1.5em]
    \item Các loại Bài tập (Quiz, Exam, Project) kế thừa từ Assessment
    \item Các loại Nội dung (Video, Text, Interactive) kế thừa từ ContentUnit
\end{itemize}

\subsubsection{Xác minh Hợp đồng}

\noindent\textit{Trước LSP (Xấu)}: Lớp con vi phạm hợp đồng của lớp cha, gây ra \texttt{UnsupportedOperationException}.

\begin{lstlisting}[language=Java, caption={Vi phạm LSP}]
// BAD: Violate LSP

// Base class assumes all can auto-score
public abstract class Assessment {
    public abstract double autoScore(String answer);
}

// Subclass 1: Works fine
public class QuizAssessment extends Assessment {
    @Override
    public double autoScore(String answer) { /* ... */ }
}

// Subclass 2: VIOLATE!
public class ProjectAssessment extends Assessment {
    @Override
    public double autoScore(String answer) {
        // Project cannot auto-score
        throw new UnsupportedOperationException("Must be manually graded"); 
    }
}

// Client code breaks when using ProjectAssessment
public class GradingService {
    public void gradeAll(List<Assessment> assessments) {
        for (Assessment a : assessments) {
            // Error! Throw exception when using ProjectAssessment
            a.autoScore(userAnswer); 
        }
    }
}
\end{lstlisting}

\noindent\textit{Sau LSP (Tốt)}: Tách interface (Sử dụng ISP) để đảm bảo các lớp con chỉ thực thi các hành vi mà chúng thực sự hỗ trợ.

\begin{lstlisting}[language=Java, caption={Tuân thủ LSP bằng cách tách interface}]
// GOOD: Follow LSP by separating interfaces

// Common interface
public interface Assessment {
    String getTitle();
}

// Interface for auto-scoring
public interface ScorableAssessment extends Assessment {
    double autoScore(String answer);
}

// Interface for manual scoring
public interface ManualAssessment extends Assessment {
    void sendForReview(String submission);
}

// Quiz follows "Scorable" contract
public class QuizAssessment implements ScorableAssessment {
    @Override
    public double autoScore(String answer) { /* ... */ }
    @Override
    public String getTitle() { /* ... */ }
}

// Project follows "Manual" contract
public class ProjectAssessment implements ManualAssessment {
    @Override
    public void sendForReview(String submission) { /* ... */ }
    @Override
    public String getTitle() { /* ... */ }
}

// Client code is type-safe
public class GradingService {
    public void gradeAll(List<ScorableAssessment> assessments) {
        for (ScorableAssessment a : assessments) {
            // Safe! All support autoScore()
            a.autoScore(userAnswer);
        }
    }
}
\end{lstlisting}

\subsection{Nguyên tắc Phân tách Giao diện (Interface Segregation Principle - ISP)}

\subsubsection{Thiết kế Giao diện}

\noindent Định nghĩa: ``Client không nên bị buộc phải phụ thuộc vào các phương thức (trong interface) mà chúng không sử dụng.''

\noindent Áp dụng trong ITS: Chúng ta tránh các ``fat interface'' (interface béo phì). Thay vào đó, chúng ta tạo ra các interface nhỏ, tập trung (role-based interfaces).

\noindent Áp dụng trong:
\begin{itemize}[leftmargin=1.5em]
    \item Repository: Tách biệt Read (Đọc) và Write (Ghi). Đây là nền tảng của mô hình CQRS
    \item Service: Tách biệt các nghiệp vụ khác nhau
\end{itemize}

\subsubsection{Ví dụ}

\noindent\textit{Trước ISP (Xấu)}: Một \texttt{LearnerRepository} béo phì.

\begin{lstlisting}[language=Go, caption={Vi phạm ISP - Fat Interface}]
// BAD: Fat Interface
type LearnerRepository interface {
    // Read operations
    GetProfile(id string) (*Profile, error)
    GetSkillMastery(id string) (map[string]float64, error)
    
    // Write operations
    SaveProfile(profile *Profile) error
    UpdateMasteryScore(id string, skill string, score float64) error
    
    // Analytics
    GenerateReport(id string) (*Report, error)
}

// Problem: `ScoringService` only needs `GetSkillMastery` and `UpdateMasteryScore`
// but forced to know about Profile and Report.
type ScoringService struct {
    learnerRepo LearnerRepository 
}
\end{lstlisting}

\noindent\textit{Sau ISP (Tốt)}: Tách thành các interface nhỏ, theo vai trò.

\begin{lstlisting}[language=Go, caption={Tuân thủ ISP - Interface nhỏ, tập trung}]
// GOOD: Small, focused interfaces (role-based)

// Interface for reading Profile
type ProfileReader interface {
    GetProfile(id string) (*Profile, error)
}

// Interface for reading/writing Skill
type SkillMasteryReader interface {
    GetSkillMastery(id string) (map[string]float64, error)
}
type SkillMasteryWriter interface {
    UpdateMasteryScore(id string, skill string, score float64) error
}

// Implementation can implement multiple interfaces
type LearnerRepository struct { /* ... */ }
func (r *LearnerRepository) GetProfile(...) (*Profile, error) { /* ... */ }
func (r *LearnerRepository) GetSkillMastery(...) (map[string]float64, error) { /* ... */ }
func (r *LearnerRepository) UpdateMasteryScore(...) error { /* ... */ }

// Client (ScoringService) only depends on what it needs
type ScoringService struct {
    skillReader SkillMasteryReader
    skillWriter SkillMasteryWriter
}

// Client (AdaptiveEngine) only depends on what it needs
type AdaptiveEngine struct {
    profileReader ProfileReader
    skillReader   SkillMasteryReader
}
\end{lstlisting}

\subsection{Nguyên tắc Đảo ngược Phụ thuộc (Dependency Inversion Principle - DIP)}

\subsubsection{Tác động Kiến trúc}

\noindent Định nghĩa: ``Các module cấp cao (policy) không nên phụ thuộc vào các module cấp thấp (detail). Cả hai nên phụ thuộc vào abstractions (interfaces).''

\noindent Tác động: Đây là nguyên tắc quan trọng nhất đối với kiến trúc của chúng ta.
\begin{itemize}[leftmargin=1.5em]
    \item Nó là nền tảng của Clean Architecture (ADR-3)
    \item Nó đảm bảo Testability (AC4) bằng cách cho phép mock dependencies
    \item Nó cho phép Modularity (AC1) bằng cách cho phép thay thế các triển khai (implementation) (ví dụ: đổi \texttt{PostgresRepository} thành \texttt{MongoRepository} mà không ảnh hưởng đến nghiệp vụ)
\end{itemize}

\subsubsection{Ví dụ Triển khai}

\indentpar \indentpar Ví dụ này cho thấy cách Tầng Application (cấp cao) phụ thuộc vào Interface, và Tầng Infrastructure (cấp thấp) cũng phụ thuộc vào Interface đó.

\noindent Tầng Application (Cấp cao): Định nghĩa Use Case và Interface nó cần.

\begin{lstlisting}[language=Java, caption={Tầng Application - Phụ thuộc vào Abstraction}]
// Application Layer - Depends on Abstraction

// Abstraction (Interface)
package application.ports;
public interface LearnerModelRepository {
    LearnerModel findById(Long id);
    void save(LearnerModel model);
}

// High-level module (Policy) - Depends on Interface
package application;

@Service
public class UpdateSkillMasteryUseCase {
    // Depends on Abstraction, not Concretion
    private final LearnerModelRepository repository; 

    // Dependency is injected (DI)
    @Autowired
    public UpdateSkillMasteryUseCase(LearnerModelRepository repo) {
        this.repository = repo;
    }
    
    public void execute(Long learnerId, String skill, double score) {
        // Pure business logic
        LearnerModel model = repository.findById(learnerId);
        model.updateSkill(skill, score); // Business logic
        repository.save(model); // Call interface
    }
}
\end{lstlisting}

\noindent Tầng Infrastructure (Cấp thấp): Cung cấp triển khai (implementation) cho Interface.

\begin{lstlisting}[language=Java, caption={Tầng Infrastructure - Cung cấp Concretion}]
// Infrastructure Layer - Provides Concretion

@Repository
public class PostgresLearnerModelRepository implements LearnerModelRepository {
    
    @Autowired
    private JdbcTemplate jdbcTemplate; // Concrete implementation

    @Override
    public LearnerModel findById(Long id) {
        // Specific SQL code
        return jdbcTemplate.queryForObject("SELECT ...", ...);
    }

    @Override
    public void save(LearnerModel model) {
        // Specific SQL code
        jdbcTemplate.update("INSERT ...", ...);
    }
}
\end{lstlisting}

\subsubsection{Lợi ích Kiểm thử (Testing Benefits)}

\indentpar \indentpar DIP là chìa khóa để đạt được Testability (AC4) và mục tiêu Coverage $> 80\%$ (ADR-5). Chúng ta có thể kiểm thử logic nghiệp vụ (UseCase) mà không cần CSDL.

\begin{lstlisting}[language=Java, caption={Kiểm thử UseCase mà không cần CSDL}]
// Test UseCase without database

@Test
public void testUpdateSkillMastery() {
    // 1. Build (Mock) Abstraction (Interface)
    LearnerModelRepository mockRepo = mock(LearnerModelRepository.class);
    LearnerModel fakeModel = new LearnerModel(1L);
    
    // 2. Define behavior for Mock
    when(mockRepo.findById(1L)).thenReturn(fakeModel);
    
    // 3. Inject (Inject) Mock into UseCase
    UpdateSkillMasteryUseCase useCase = new UpdateSkillMasteryUseCase(mockRepo);
    
    // 4. Execute business logic
    useCase.execute(1L, "algebra", 0.8);
    
    // 5. Verify that the logic called the interface correctly
    // (We don't care about the database, only that the business logic calls 'save')
    verify(mockRepo).save(any(LearnerModel.class));
    assertEquals(0.8, fakeModel.getSkillScore("algebra"));
}
\end{lstlisting}

\subsection{Số liệu và Xác minh SOLID}

\indentpar \indentpar Nhóm sử dụng các công cụ phân tích tĩnh (static analysis) để liên tục đo lường mức độ tuân thủ SOLID.

\subsubsection{Số liệu Code}

\indentpar \indentpar Các số liệu này được tích hợp vào CI/CD pipeline (ADR-5) để đảm bảo chất lượng.

\renewcommand{\arraystretch}{1.8}
\begin{table}[H]
    \centering
    \small
    \begin{tabularx}{\textwidth}{|>{\centering\arraybackslash}p{3cm}|>{\centering\arraybackslash}p{1.8cm}|>{\centering\arraybackslash}p{2cm}|>{\centering\arraybackslash}p{2cm}|>{\noindent\justifying\arraybackslash}X|}
        \hline
        \textbf{Số liệu}\rule{0pt}{1.6em} & \textbf{Mục tiêu} & \textbf{Công cụ} & \textbf{Trạng thái} & \textbf{Ý nghĩa (liên quan đến SOLID)}                                      \\
        \hline
        Cyclomatic Complexity             & $< 10$            & SonarQube        & 7.2                 & SRP/OCP: Độ phức tạp thấp cho thấy các phương thức tập trung, ít if/else    \\
        \hline
        Coupling (Afferent/Efferent)      & $< 5$             & JDepend          & 3.8                 & DIP/ISP: Khớp nối (coupling) thấp cho thấy sự phụ thuộc vào abstraction     \\
        \hline
        Cohesion (LCOM4)                  & $> 0.8$           & SonarQube        & 0.85                & SRP: Độ gắn kết (cohesion) cao cho thấy các lớp có trách nhiệm rõ ràng      \\
        \hline
        Test Coverage                     & $> 80\%$          & JaCoCo           & 78\%                & DIP: Tỷ lệ coverage cao là kết quả của việc áp dụng DIP, cho phép unit test \\
        \hline
    \end{tabularx}
    \caption{Số liệu đo lường tuân thủ SOLID}
    \label{tab:solid-metrics}
\end{table}
\renewcommand{\arraystretch}{1.0}

\subsubsection{Checklist Đánh giá (Code Review Checklist)}

\indentpar \indentpar Checklist này được sử dụng trong mọi Pull Request:

\begin{itemize}[leftmargin=1.5em]
    \item SRP: Lớp này có nhiều hơn một lý do để thay đổi không? (Ví dụ: Thay đổi nghiệp vụ VÀ thay đổi CSDL?)
    \item OCP: Nếu thêm một tính năng tương tự (ví dụ: loại gợi ý mới), chúng ta phải sửa code ở đây hay thêm code mới? (Phải là ``thêm'')
    \item LSP: Lớp con này có vi phạm bất kỳ hợp đồng nào của lớp cha không? (Ví dụ: Ném \texttt{UnsupportedOperationException}?)
    \item ISP: Interface này có ``béo'' không? Client sử dụng nó có cần tất cả các phương thức không?
    \item DIP: Module cấp cao này có import bất kỳ thứ gì từ tầng Infrastructure (ví dụ: \texttt{Postgres...}) không? (Không được phép)
    \item Tests: Unit test có sử dụng Mocks/Stubs không? (Xác minh DIP)
\end{itemize}

\section{Phản ánh và Đánh giá}

\indentpar \indentpar Chương này đánh giá kiến trúc đã đề xuất dựa trên các mục tiêu (ACs) và phân tích các bài học kinh nghiệm.

\subsection{Đánh giá Kiến trúc}

\subsubsection{Kịch bản Thuộc tính Chất lượng}

\indentpar \indentpar Đánh giá kiến trúc dựa trên các kịch bản thực tế.

\renewcommand{\arraystretch}{1.6}
\begin{table}[H]
    \centering
    \small
    \begin{tabularx}{\textwidth}{|>{\centering\arraybackslash}p{2.5cm}|>{\noindent\justifying\arraybackslash}X|>{\noindent\justifying\arraybackslash}X|>{\noindent\justifying\arraybackslash}p{2.5cm}|>{\centering\arraybackslash}p{1.5cm}|}
        \hline
        \textbf{Thuộc tính (AC)}\rule{0pt}{1.6em} & \textbf{Kịch bản}                                                                                       & \textbf{Phản ứng Kiến trúc}                                                                                                                                                    & \textbf{Chỉ số Đo lường}                                       & \textbf{Kết quả} \\
        \hline
        Performance (AC3)                         & 5.000 người dùng đồng thời nộp bài (UC-10) và yêu cầu phản hồi tức thì                                  & 1. Polyglot (ADR-1): Dùng Golang cho ScoringService\newline 2. EDA: Tách rời việc cập nhật LearnerModel\newline 3. Caching (Redis) cho PII                                     & p95 latency $< 500$ms cho phản hồi tức thì                     & passed       \\
        \hline
        Scalability (AC2)                         & Lượng người dùng tăng gấp 10 lần trong mùa cao điểm                                                     & 1. Kubernetes: Triển khai trên K8s\newline 2. HPA: Horizontal Pod Autoscaler\newline 3. Stateless: Services là stateless (JWT/ADR-6)                                           & Service tự động scale-out (từ 3 lên 15 pod)                    & passed       \\
        \hline
        Modularity (AC1) / Deployability (AC5)    & Team AI muốn triển khai thuật toán gợi ý mới (V2) mà không làm gián đoạn người dùng đang học (V1)       & 1. OCP: AdaptiveEngine phụ thuộc vào interface\newline 2. Microservices: AdaptiveEngine là service độc lập\newline 3. Blue/Green deployment trên K8s                           & Zero downtime. Chuyển đổi 100\% traffic sang V2 trong < 5 phút & passed       \\
        \hline
        Testability (AC4)                         & Logic nghiệp vụ của AdaptiveEngine phải được xác minh là chính xác 100\% mà không cần chạy toàn bộ CSDL & 1. Clean Arch: Logic nghiệp vụ cô lập trong tầng Application/Domain\newline 2. DIP: Use Case phụ thuộc vào interfaces\newline 3. Testing Pyramid: Unit Tests mock repositories & Code Coverage cho module logic nghiệp vụ $> 85\%$              & passed       \\
        \hline
        Security (AC6) / Compliance               & Một service (ví dụ: ScoringService) bị xâm nhập bởi kẻ tấn công                                         & 1. Tách PII: Chỉ UserManagementService lưu PII\newline 2. Mã hóa: PII được mã hóa (at-rest) bằng pgcrypto\newline 3. AuthZ (ADR-6): API Gateway chặn cuộc gọi trái phép        & Kẻ tấn công không thể truy cập PII từ service bị xâm nhập      & passed       \\
        \hline
    \end{tabularx}
    \caption{Kịch bản đánh giá các thuộc tính chất lượng}
    \label{tab:qa-scenarios}
\end{table}
\renewcommand{\arraystretch}{1.0}

\subsubsection{Phân tích Đánh đổi Kiến trúc}

\indentpar \indentpar Phân tích này xác nhận lại các đánh đổi đã được chấp nhận.

\noindent Sensitivity Points (Điểm nhạy cảm):
\begin{itemize}[leftmargin=1.5em]
    \item Hiệu năng CSDL (Postgres): Hiệu năng của PostgreSQL ảnh hưởng trực tiếp đến các service Java. Tối ưu hóa query và indexing là rất quan trọng
    \item Độ trễ Mạng (Microservices): Kiến trúc microservice làm tăng các cuộc gọi mạng. Luồng ``Tạo Báo cáo Giảng viên'' (yêu cầu tổng hợp dữ liệu từ 3 service) là một điểm nhạy cảm về độ trễ
    \item Tỷ lệ Cache Hit: Tỷ lệ cache-hit-ratio của Redis (cho PII) ảnh hưởng trực tiếp đến độ trễ của AdaptiveEngine
\end{itemize}

\noindent Trade-off Points (Điểm Đánh đổi):
\begin{itemize}[leftmargin=1.5em]
    \item Microservices Complexity vs. Modularity: Chúng ta chấp nhận độ phức tạp vận hành cao của Microservices để đạt được Modularity (cho FR12) và Scalability (AC2)
    \item Eventual Consistency vs. Performance: Chúng ta chọn mô hình Event-Driven cho việc chấm điểm. Điều này tăng hiệu năng (AC3) (phản hồi tức thì $< 500$ms) nhưng đánh đổi bằng tính nhất quán tức thời (Learner Model được cập nhật sau vài giây)
    \item Polyglot Programming vs. Team Expertise: Chúng ta chọn Polyglot (ADR-1) để tối ưu hiệu năng (Go) và bảo trì (Java). Chúng ta chấp nhận rủi ro về chi phí đào tạo và sự phức tạp của CI/CD pipeline
\end{itemize}

\noindent Risks (Rủi ro):
\begin{itemize}[leftmargin=1.5em]
    \item Operational Complexity: Vận hành một stack polyglot (Java + Go) trên Kubernetes với RabbitMQ và nhiều CSDL (Postgres + Mongo) đòi hỏi đội ngũ DevOps rất trưởng thành
    \item Distributed Transaction Management: Việc thiếu kinh nghiệm triển khai Saga pattern (để đảm bảo nhất quán dữ liệu) là rủi ro lớn nhất
    \item Team Learning Curve: Đội ngũ Java cần học Go, và toàn bộ đội ngũ cần hiểu rõ Clean Architecture/DIP
\end{itemize}

\noindent Non-Risks (Không phải Rủi ro):
\begin{itemize}[leftmargin=1.5em]
    \item Technology Maturity: Tất cả các công nghệ được chọn (Java/Spring, Go, K8s, Postgres, RabbitMQ) đều đã được chứng minh, trưởng thành và có cộng đồng lớn
    \item Vendor Lock-in: Bằng cách sử dụng K8s, Postgres, RabbitMQ (tất cả đều là mã nguồn mở), chúng ta tránh được việc bị khóa chặt vào một nhà cung cấp đám mây
\end{itemize}

\subsection{Phân tích Tác động của SOLID}

\subsubsection{Các Cải tiến từ SOLID}

\indentpar \indentpar Việc áp dụng SOLID đã tạo ra những cải tiến đáng kể, đặc biệt khi so sánh với các dự án ``monolith'' truyền thống.

\noindent Cải tiến Định lượng (Ước tính):

\renewcommand{\arraystretch}{1.6}
\begin{table}[H]
    \centering
    \small
    \begin{tabularx}{\textwidth}{|>{\centering\arraybackslash}p{3cm}|>{\centering\arraybackslash}p{2.8cm}|>{\centering\arraybackslash}p{2.8cm}|>{\centering\arraybackslash}p{1.5cm}|>{\noindent\justifying\arraybackslash}X|}
        \hline
        \textbf{Số liệu}\rule{0pt}{1.6em} & \textbf{Trước SOLID (Monolith)}   & \textbf{Sau SOLID (Clean Arch)}    & \textbf{Cải tiến} & \textbf{Ý nghĩa}                               \\
        \hline
        Test Coverage                     & \textasciitilde45\% (Chủ yếu E2E) & \textasciitilde85\% (Chủ yếu Unit) & +88\%             & DIP cho phép Unit Test logic nghiệp vụ (AC4)   \\
        \hline
        Build Time                        & 15 phút (Build tất cả)            & 8 phút (Build service thay đổi)    & -47\%             & SRP (cấp service) cho phép build độc lập (AC5) \\
        \hline
        Defect Rate (Bug/KLOC)            & 12/KLOC                           & 3/KLOC                             & -75\%             & DIP/SRP làm giảm lỗi hồi quy                   \\
        \hline
        Change Impact (File thay đổi)     & 5 files (trung bình/feature)      & 2 files (trung bình/feature)       & -60\%             & OCP cho phép thêm code mà không sửa code cũ    \\
        \hline
    \end{tabularx}
    \caption{Cải tiến định lượng từ việc áp dụng SOLID}
    \label{tab:solid-improvements}
\end{table}
\renewcommand{\arraystretch}{1.0}

\noindent Cải tiến Định tính:
\begin{itemize}[leftmargin=1.5em]
    \item Dễ dàng Onboarding: Nhờ SRP, developer mới có thể hiểu một service (ví dụ: ScoringService) mà không cần biết về UserManagementService
    \item Phát triển Tính năng Nhanh hơn: Nhờ OCP, việc thêm một loại gợi ý mới là một tác vụ thêm (add), không phải sửa (modify), giảm rủi ro
    \item Tự tin Tái cấu trúc (Refactoring): Nhờ DIP và Testability (AC4), developer có thể tự tin tái cấu trúc code nghiệp vụ vì đã có bộ Unit Test bảo vệ
\end{itemize}

\subsubsection{Những Thách thức Gặp phải}

\noindent Sự phức tạp ban đầu (Initial Complexity):
\begin{itemize}[leftmargin=1.5em]
    \item \textit{Thách thức}: Áp dụng Clean Architecture/DIP cho các tính năng CRUD đơn giản (ví dụ: quản lý Tags) dẫn đến ``over-engineering'' (quá nhiều lớp/interface cho một nghiệp vụ đơn giản)
    \item \textit{Giải pháp}: Bắt đầu đơn giản. Áp dụng DIP nghiêm ngặt cho các logic nghiệp vụ lõi (AI, Scoring), nhưng có thể linh hoạt hơn với các service CRUD phụ trợ
\end{itemize}

\noindent Tiếp nhận của Đội ngũ (Team Adoption):
\begin{itemize}[leftmargin=1.5em]
    \item \textit{Thách thức}: Các developer (đặc biệt là junior) có cách hiểu khác nhau về SOLID, dẫn đến tranh cãi trong code review (ví dụ: ``Thế này đã đủ SRP chưa?'')
    \item \textit{Giải pháp}: Thúc đẩy Đánh giá code (Code Reviews) và Lập trình cặp (Pair Programming). Xây dựng một checklist làm tiêu chuẩn chung
\end{itemize}

\noindent Chi phí Hiệu năng (Performance Overhead):
\begin{itemize}[leftmargin=1.5em]
    \item \textit{Thách thức}: Các tầng abstraction (ví dụ: gọi qua interface, mapping DTOs) có tạo ra chi phí (latency) nhỏ, mặc dù không đáng kể so với chi phí mạng
    \item \textit{Giải pháp}: Chỉ tối ưu khi đã đo lường (measure). Sử dụng caching chiến lược (Redis) tại các điểm nóng để bù đắp chi phí
\end{itemize}

\subsection{Bài học Kinh nghiệm}

\subsubsection{Những điều Hoạt động Tốt}

\noindent Clean Architecture trong Microservices:
\begin{itemize}[leftmargin=1.5em]
    \item Sự kết hợp giữa SRP (cấp service) và DIP (trong service) là một thành công lớn
    \item Ranh giới rõ ràng (ví dụ: domain, application, infrastructure) đã tăng tốc độ phát triển song song
    \item Việc kiểm thử (Testing) trở nên dễ dàng nhờ DIP
\end{itemize}

\noindent Event-Driven cho các Thành phần AI:
\begin{itemize}[leftmargin=1.5em]
    \item Quyết định tách rời (decouple) ScoringService và LearnerModelService qua RabbitMQ là rất đúng đắn
    \item Nó giúp đạt được AC3: Performance ($< 500$ms) bằng cách cho phép xử lý bất đồng bộ các mô hình ML/AI (cập nhật LearnerModel)
\end{itemize}

\noindent Polyglot Programming (ADR-1):
\begin{itemize}[leftmargin=1.5em]
    \item Chiến lược ``dùng đúng công cụ'' đã được chứng minh:
    \item Java (Spring Boot) rất mạnh cho các nghiệp vụ CRUD phức tạp, bảo mật (Auth, User, Content) nhờ hệ sinh thái trưởng thành
    \item Golang cực kỳ hiệu quả cho các tác vụ tính toán, hiệu năng cao, I/O-bound (API Gateway, Scoring)
\end{itemize}

\subsubsection{Những điều có thể Cải thiện}

\noindent Tài liệu Hóa (Documentation):
\begin{itemize}[leftmargin=1.5em]
    \item API documentation (OpenAPI/Swagger) không được cập nhật kịp thời, gây khó khăn cho team frontend
    \item \textit{Giải pháp}: Tự động hóa việc tạo spec OpenAPI từ code. Áp dụng ADR (Architecture Decision Records) ngay từ đầu (thay vì viết lại sau) để ghi lại lý do (rationale) đằng sau các quyết định
\end{itemize}

\noindent Chiến lược Giám sát (Monitoring Strategy):
\begin{itemize}[leftmargin=1.5em]
    \item Distributed Tracing (Theo vết Phân tán) được thêm vào quá muộn
    \item Việc debug một request (ví dụ: SubmissionCompleted) đi từ Go \(\rightarrow\) RabbitMQ \(\rightarrow\) Go (service khác) ban đầu rất khó khăn
    \item \textit{Giải pháp}: Phải áp dụng Observability (AC9) ngay từ Ngày 1. Bắt buộc mọi request phải có Correlation ID (Trace ID) đi qua tất cả các service
\end{itemize}

\noindent Chiến lược Kiểm thử (Testing Strategy):
\begin{itemize}[leftmargin=1.5em]
    \item Chúng ta đã làm tốt Unit Test (nhờ DIP) và E2E Test
    \item Tuy nhiên, chúng ta thiếu Contract Testing (Kiểm thử Hợp đồng) giữa các service. Điều này dẫn đến lỗi khi một service (ví dụ: UserManagementService) thay đổi API mà ContentService không biết
    \item \textit{Giải pháp}: Bổ sung Contract Testing (dùng Pact hoặc Spring Cloud Contract) vào pipeline (ADR-5)
\end{itemize}

\subsection{Khuyến nghị Tương lai}

\subsubsection{Ngắn hạn (3-6 tháng)}

\begin{itemize}[leftmargin=1.5em]
    \item Triển khai Circuit Breakers: Hiện tại chúng ta dựa vào K8s/Istio. Cần triển khai thêm ở cấp độ ứng dụng (ví dụ: Resilience4j cho Java, Hystrix-go cho Go) để tăng khả năng chịu lỗi
    \item Thêm Contract Testing: Triển khai Pact để xác minh API giữa các service
    \item Tối ưu hóa CSDL: Truy vết và sửa các truy vấn N+1 trong các service Java
    \item Triển khai Feature Toggles (Cờ Tính năng): Cho phép bật/tắt tính năng mới (ví dụ: thuật toán AI V3) cho một nhóm người dùng mà không cần deploy lại
    \item Tăng cường Giám sát: Thêm các business metrics (số liệu nghiệp vụ) tùy chỉnh vào Prometheus (ví dụ: số lượng bài nộp/phút, độ trễ p99 của thuật toán AI)
\end{itemize}

\subsubsection{Dài hạn (6-12 tháng)}

\begin{itemize}[leftmargin=1.5em]
    \item Phát triển lên Serverless: Một số tác vụ (như ScoringService) có tải không liên tục (sporadic loads). Chuyển các hàm này sang AWS Lambda / Google Cloud Functions để giảm chi phí vận hành (idle cost) và tự động scale-to-zero
    \item Quản lý Mô hình AI (MLOps):
          \begin{itemize}
              \item Xây dựng một pipeline MLOps hoàn chỉnh để tự động hóa việc training và deploy các mô hình AI mới
              \item Hỗ trợ A/B testing chính thức cho các mô hình AI (hiện tại FR12 là Blue/Green)
              \item Quản lý phiên bản (versioning) và rollback mô hình
          \end{itemize}
    \item Hỗ trợ Đa Người thuê (Multi-tenancy):
          \begin{itemize}
              \item Tái kiến trúc để hỗ trợ nhiều trường học (tenants) trên cùng một hạ tầng
              \item Có thể yêu cầu tách biệt CSDL (database-per-tenant) hoặc schema-per-tenant
          \end{itemize}
\end{itemize}

\subsubsection{Sổ nợ Kỹ thuật (Technical Debt Register)}

\indentpar \indentpar Ghi lại các nợ kỹ thuật đã biết để lên kế hoạch xử lý.

\renewcommand{\arraystretch}{1.6}
\begin{table}[H]
    \centering
    \small
    \begin{tabularx}{\textwidth}{|>{\noindent\justifying\arraybackslash}p{3cm}|>{\centering\arraybackslash}p{1.5cm}|>{\centering\arraybackslash}p{1.5cm}|>{\centering\arraybackslash}p{1.5cm}|>{\noindent\justifying\arraybackslash}X|}
        \hline
        \textbf{Hạng mục Nợ}\rule{0pt}{1.6em}      & \textbf{Tác động} & \textbf{Ưu tiên} & \textbf{Nỗ lực} & \textbf{Kế hoạch Xử lý}                                                                        \\
        \hline
        Thiếu Integration Tests (cho CSDL)         & Cao               & 1 (Cao)          & 2 tuần          & Bổ sung Testcontainers vào pipeline (ADR-5) để kiểm thử với CSDL thật (Postgres, Mongo)        \\
        \hline
        Cấu hình Hardcode                          & Trung bình        & 2                & 1 tuần          & Đưa tất cả cấu hình (ví dụ: RabbitMQ host) ra ngoài (Externalize) vào K8s ConfigMaps / Secrets \\
        \hline
        Không có Phiên bản API (No API Versioning) & Cao               & 1 (Cao)          & 3 tuần          & Áp dụng URL versioning (ví dụ: /api/v1/...) cho tất cả các public API (tại API Gateway)        \\
        \hline
        Thiếu Contract Testing                     & Cao               & 1 (Cao)          & 3 tuần          & Triển khai Pact                                                                                \\
        \hline
        Truy vấn N+1 (trong ContentService)        & Trung bình        & 2                & 1 tuần          & Dùng JOIN FETCH (JPA) hoặc batch loading (GraphQL) để tối ưu hóa                               \\
        \hline
    \end{tabularx}
    \caption{Sổ nợ kỹ thuật và kế hoạch xử lý}
    \label{tab:technical-debt}
\end{table}
\renewcommand{\arraystretch}{1.0}
