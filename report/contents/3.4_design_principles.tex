\subsection{Nguyên tắc thiết kế}

\indentpar \indentpar Sau khi xác lập kiến trúc tổng thể (Mục~3.2) và các quyết định kỹ thuật chi tiết (Mục~3.3), phần này trình bày các nguyên tắc thiết kế cốt lõi (design principles) để hiện thực hóa các đặc tính kiến trúc (ACs) đã ưu tiên---đặc biệt là \textbf{AC1: Modularity}, \textbf{AC4: Testability}, và \textbf{AC7: Maintainability}. Các nguyên tắc này định hình cấu trúc bên trong của mỗi service và cách chúng tương tác với nhau.

\subsubsection{Các nguyên tắc cốt lõi}

\indentpar \indentpar Các nguyên tắc này là nền tảng triết lý cho mọi quyết định thiết kế.

\indent\textbf{a. Domain-Driven Design (DDD)}

\indentpar DDD là nguyên tắc chủ đạo để phân tích nghiệp vụ và thu hẹp khoảng cách giữa logic nghiệp vụ cốt lõi và thiết kế kiến trúc. Chúng ta sử dụng DDD để xác định ranh giới (boundaries) cho các microservice. Các khái niệm DDD chính được áp dụng bao gồm:

\begin{itemize}[leftmargin=0.7cm]
    \item \textbf{Bounded Contexts (Bối cảnh Bó buộc):} Hệ thống được phân rã thành các ``ranh giới nghiệp vụ'' (Bounded Context) rõ ràng. Mỗi Bounded Context sẽ (cuối cùng) trở thành một microservice hoặc một nhóm microservice liên quan, ví dụ: `User Management`, `Content`, và `Learner Model`.
    \item \textbf{Aggregates (Tổng thể):} Là khái niệm trung tâm để đảm bảo tính nhất quán dữ liệu. Mỗi Aggregate xác định một ranh giới giao dịch (transaction boundary). Các Aggregate chính đã được xác định bao gồm `LearnerAggregate`, `LearnerModelAggregate`, và `ContentAggregate`.
    \item \textbf{Entities \& Value Objects:} Phân biệt rõ các đối tượng có danh tính (Entities, ví dụ: `Learner`, `Course`) và các đối tượng thuộc tính bất biến (Value Objects, ví dụ: `MetadataTag`, `ProgressRecord`).
    \item \textbf{Domain Services \& Domain Events:} Các nghiệp vụ phức tạp liên quan đến nhiều Aggregate được xử lý bởi `Domain Services` (ví dụ: `AdaptivePathGenerator`, `ScoringEngine`). Giao tiếp giữa các Aggregate/Context (ví dụ: khi chấm điểm xong) được thực hiện bất đồng bộ thông qua `Domain Events` (ví dụ: `SubmissionCompleted`).
\end{itemize}

\indent\textbf{b. SOLID Principles}

\indentpar Việc tuân thủ 5 nguyên tắc SOLID là bắt buộc để đạt được \textbf{AC7: Maintainability} và \textbf{AC4: Testability}. Các nguyên tắc này được áp dụng chi tiết cho cả code Java và Golang:

\begin{itemize}[leftmargin=0.7cm]
    \item \textbf{S - Single Responsibility Principle (SRP):} Mỗi class/module chỉ có một lý do để thay đổi. Ví dụ, một `UserService` không nên tự gửi email; nó nên ủy quyền cho một `EmailService` riêng biệt.
    \item \textbf{O - Open/Closed Principle (OCP):} Mở rộng cho việc mở rộng nhưng đóng cho việc sửa đổi. Nguyên tắc này được thực thi bằng cách sử dụng các interface. Ví dụ: `GeneratePathUseCase` phụ thuộc vào interface `PathGenerator`, cho phép chúng ta dễ dàng thêm một `AIPathGenerator` mới mà không cần sửa đổi `BasicPathGenerator` hay chính Use Case đó.
    \item \textbf{L - Liskov Substitution Principle (LSP):} Các đối tượng của lớp con có thể thay thế các đối tượng của lớp cha mà không làm thay đổi tính đúng đắn của chương trình.
    \item \textbf{I - Interface Segregation Principle (ISP):} Client không nên bị buộc phải phụ thuộc vào các interface mà chúng không sử dụng. Thay vì một ``fat interface'' `LearnerService`, chúng ta chia nhỏ nó thành các interface tập trung như `ProfileReader`, `SkillMasteryReader`, và `SkillMasteryWriter`.
    \item \textbf{D - Dependency Inversion Principle (DIP):} Các module cấp cao không nên phụ thuộc vào các module cấp thấp; cả hai nên phụ thuộc vào abstractions (interfaces). Đây là nguyên tắc nền tảng của Clean Architecture.
\end{itemize}

\indent\textbf{c. Clean/Hexagonal Architecture}

\indentpar Đây là kiểu kiến trúc nội bộ (Internal Architecture Pattern) bắt buộc được chọn cho \textbf{TẤT CẢ} các microservice (cả Java và Golang).

\begin{itemize}[leftmargin=0.7cm]
    \item \textbf{Mục tiêu:} Là nguyên tắc kỹ thuật chính để đạt được \textbf{AC4: Testability}.
    \item \textbf{Dependency Rule:} Nguyên tắc cốt lõi là \textbf{Quy tắc Phụ thuộc (Dependency Rule)}. Mọi phụ thuộc phải hướng vào trong. Các lớp ngoài (Frameworks, DBs) phụ thuộc vào các lớp trong (Use Cases, Entities). Logic nghiệp vụ cốt lõi không bao giờ được phép biết về chi tiết hạ tầng (ví dụ: logic `ScoringEngine` không biết nó đang dùng Postgres hay Mongo).
    \item \textbf{Cấu trúc:} Các service được tổ chức thành các tầng đồng tâm: `Domain` (trong cùng), `Application` (Use Cases), `Adapters` (Controllers, Repositories), và `Infrastructure` (Frameworks, Drivers).
\end{itemize}

\subsubsection{Các mẫu triển khai và tiêu chuẩn}

\indentpar Để thực thi các nguyên tắc trên, các mẫu (patterns) và tiêu chuẩn kỹ thuật cụ thể đã được định nghĩa chi tiết trong Mục~3.3 (Architecture Decision Records). Phần này tóm tắt vai trò của từng mẫu trong việc hiện thực hóa các nguyên tắc cốt lõi:

\indent\textbf{a. Repository Pattern (ADR-4)}

\indentpar Đây là mẫu kỹ thuật bắt buộc để triển khai nguyên tắc DIP và Clean Architecture, đảm bảo tầng domain và application không phụ thuộc vào chi tiết hạ tầng cụ thể (ví dụ: ORM, SQL). Chi tiết đầy đủ về quyết định này, bao gồm context, rationale, và trade-offs, được trình bày ở Mục~3.3, ADR-4.

\indent\textbf{b. Testing Pyramid Strategy (ADR-5)}

\indentpar Đây là tiêu chuẩn kiểm thử chính thức để đảm bảo chất lượng code và tính đúng đắn của thuật toán AI. Chiến lược này tuân theo Testing Pyramid: phần lớn là Unit Tests ($> 80\%$ coverage), kế đến là Integration Tests (dùng Testcontainers), và cuối cùng là E2E Tests cho các luồng nghiệp vụ quan trọng. Chi tiết đầy đủ xem Mục~3.3, ADR-5.

\indent\textbf{c. Centralized Security Standard (ADR-6 \& ADR-7)}

\indentpar Tiêu chuẩn bảo mật tập trung cho toàn hệ thống, bao gồm xác thực (AuthN) tại Auth Service, phân quyền (AuthZ) tại API Gateway, và bảo vệ dữ liệu cá nhân (PII) thông qua phân tách và mã hóa. Các quyết định này được giải thích đầy đủ ở Mục~3.3, ADR-6 và ADR-7.

\subsubsection{Kết luận}

\indentpar \indentpar Các nguyên tắc thiết kế được trình bày trong mục này không phải là lý thuyết suông, mà là nền tảng kỹ thuật cụ thể để hiện thực hóa kiến trúc ITS. Chúng tạo thành một ``bộ công cụ thiết kế'' (design toolkit) nhất quán, đảm bảo rằng:

\begin{itemize}[leftmargin=0.7cm]
    \item Mọi microservice đều tuân theo Clean/Hexagonal Architecture, đảm bảo AC1 (Modularity) và AC4 (Testability).
    \item Ranh giới nghiệp vụ được xác định rõ ràng thông qua Domain-Driven Design, giảm thiểu coupling và tăng cường cohesion.
    \item SOLID Principles được áp dụng nhất quán trên cả hai ngôn ngữ (Java/Golang), đảm bảo AC7 (Maintainability).
    \item Các tiêu chuẩn bảo mật và kiểm thử được thống nhất, giảm rủi ro không nhất quán giữa các team.
\end{itemize}

\vspace{0.5em}
\noindent Tóm lại, chuỗi \textbf{Mục~3.1 (ACs Prioritization) \textrightarrow{} Mục~3.2 (Architecture Style Selection) \textrightarrow{} Mục~3.3 (ADRs) \textrightarrow{} Mục~3.4 (Design Principles)} tạo thành một lộ trình thiết kế kiến trúc hoàn chỉnh, có thể truy vết từ yêu cầu phi chức năng (Mục~2.4) xuống các quyết định kỹ thuật chi tiết nhất.
