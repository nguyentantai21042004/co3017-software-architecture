\section{Hiện thực Hệ thống}

\indentpar \indentpar Chương này trình bày chi tiết quá trình hiện thực hóa hệ thống ITS (Intelligent Tutoring System). Thay vì chỉ liệt kê công nghệ, chúng tôi sẽ đi sâu vào cách thức triển khai các pattern kiến trúc (Clean Architecture, Event-Driven), cấu trúc dữ liệu, và logic nghiệp vụ cốt lõi trong từng microservice.

\subsection{Công nghệ và Môi trường Phát triển}

\indentpar \indentpar Hệ thống áp dụng chiến lược "Polyglot Programming" để tối ưu hóa hiệu năng và tốc độ phát triển:

\begin{itemize}[leftmargin=0.7cm]
    \item \textbf{Content Service (Java 17 + Spring Boot 3.x)}:
          \begin{itemize}
              \item \textbf{Lý do chọn}: Hệ sinh thái Spring mạnh mẽ cho các nghiệp vụ CRUD phức tạp, hỗ trợ tốt JPA/Hibernate cho quản lý dữ liệu quan hệ.
              \item \textbf{Thư viện chính}: Spring Web (REST), Spring Data JPA (PostgreSQL), Lombok (Boilerplate reduction).
          \end{itemize}

    \item \textbf{Scoring, Learner Model, Adaptive Engine (Go 1.23 + Gin)}:
          \begin{itemize}
              \item \textbf{Lý do chọn}: Go có hiệu năng cao (high throughput), khởi động nhanh và tiêu tốn ít tài nguyên, lý tưởng cho các service xử lý sự kiện và tính toán thời gian thực.
              \item \textbf{Thư viện chính}: Gin (Web Framework), GORM (ORM), amqp091-go (RabbitMQ client).
          \end{itemize}

    \item \textbf{Frontend (Next.js 15 + React)}:
          \begin{itemize}
              \item \textbf{Lý do chọn}: Server-Side Rendering (SSR) giúp tối ưu SEO và trải nghiệm tải trang ban đầu.
          \end{itemize}
\end{itemize}

\subsection{Chi tiết Triển khai Microservices}

\subsubsection{1. Content Service: Quản lý Nội dung Học tập}

\indentpar \indentpar Content Service được thiết kế theo \textbf{Hexagonal Architecture} để tách biệt logic nghiệp vụ khỏi framework.

\noindent\textbf{Cấu trúc Package:}
\begin{itemize}
    \item \texttt{adapter.http}: Chứa \texttt{QuestionController} xử lý REST request.
    \item \texttt{usecase}: Chứa \texttt{QuestionUseCase} (interface) và \texttt{QuestionService} (implementation).
    \item \texttt{repository}: Chứa \texttt{QuestionRepository} (JPA interface).
    \item \texttt{models}: Chứa entity \texttt{Question}.
\end{itemize}

\noindent\textbf{Mô hình Dữ liệu (Entity Question):}
Sử dụng tính năng \texttt{JSONB} của PostgreSQL để lưu trữ các lựa chọn trắc nghiệm, cho phép linh hoạt số lượng đáp án mà không cần bảng phụ.

\begin{lstlisting}[language=Java, caption={Entity Question trong Content Service}]
@Entity
@Table(name = "questions")
public class Question {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;

    @Column(columnDefinition = "TEXT")
    private String content;

    @Type(JsonBinaryType.class) // Hibernate 6 JSON support
    @Column(columnDefinition = "jsonb")
    private List<String> options; // ["A. Option 1", "B. Option 2"]

    private String skillTag;      // e.g., "math_algebra"
    private Integer difficultyLevel; // 1, 2, 3
    private Boolean isRemedial;   // Support Adaptive Learning
}
\end{lstlisting}

\noindent\textbf{API Quan trọng:}
\begin{itemize}
    \item \texttt{GET /api/content/recommend}: Endpoint này nhận tham số \texttt{skill\_tag} và \texttt{type} (REMEDIAL/STANDARD). Nó sử dụng JPA Specification để lọc câu hỏi ngẫu nhiên phù hợp, phục vụ cho Adaptive Engine.
\end{itemize}

\subsubsection{2. Scoring Service: Chấm điểm và Phát sự kiện}

\indentpar \indentpar Service này đóng vai trò là Producer trong mô hình Event-Driven.

\noindent\textbf{Luồng xử lý (Submission Flow):}
\begin{enumerate}
    \item \textbf{Nhận bài nộp}: Client gửi \texttt{POST /api/scoring/submit} với \texttt{question\_id} và \texttt{answer}.
    \item \textbf{Xác thực đáp án}: Service gọi nội bộ sang Content Service để lấy đáp án đúng (trong tương lai sẽ cache bước này bằng Redis).
    \item \textbf{Tính điểm}: So sánh string (MVP) hoặc chạy thuật toán AI (Future).
    \item \textbf{Lưu DB}: Ghi kết quả vào bảng \texttt{submissions} trong \texttt{scoring\_db}.
    \item \textbf{Publish Event (Async)}: Sử dụng Goroutine để gửi sự kiện vào RabbitMQ mà không block phản hồi HTTP.
\end{enumerate}

\begin{lstlisting}[language=Go, caption={Cấu trúc sự kiện SubmissionCompleted}]
type SubmissionEvent struct {
    Event     string    `json:"event"` // "SubmissionCompleted"
    UserID    string    `json:"user_id"`
    SkillTag  string    `json:"skill_tag"`
    Score     int       `json:"score_obtained"`
    Timestamp time.Time `json:"timestamp"`
}
// Publisher code snippet
go func() {
    ch.PublishWithContext(ctx, "its.events", "submission.scored", ..., body)
}()
\end{lstlisting}

\subsubsection{3. Learner Model Service: Cập nhật Trạng thái Người học}

\indentpar \indentpar Service này hoạt động song song hai tiến trình: API Server (phục vụ truy vấn) và Worker (xử lý sự kiện).

\noindent\textbf{Cơ chế Consumer:}
Worker lắng nghe queue \texttt{learner.updates}. Khi nhận được \texttt{SubmissionEvent}, nó tính toán lại điểm thông thạo (Mastery Score) cho kỹ năng tương ứng.

\noindent\textbf{Logic cập nhật Mastery (MVP):}
Hiện tại sử dụng công thức trung bình cộng có trọng số (Weighted Average) đơn giản:
\[ NewMastery = (OldMastery \times 0.7) + (NewScore \times 0.3) \]
Điều này giúp điểm số phản ánh cả lịch sử lẫn kết quả mới nhất.

\subsubsection{4. Adaptive Engine: Điều phối Lộ trình học}

\indentpar \indentpar Đây là thành phần thể hiện rõ nhất tính "Thông minh" (Intelligent) của hệ thống.

\noindent\textbf{Thuật toán Thích ứng (Adaptive Algorithm):}
\begin{enumerate}
    \item Client gọi \texttt{POST /api/adaptive/next-lesson}.
    \item Engine gọi Learner Model Service: \texttt{GET /internal/mastery?user\_id=...}
    \item \textbf{Quyết định Phân nhánh}:
          \begin{itemize}
              \item Nếu \texttt{mastery\_score < 50}: Người học đang gặp khó khăn. $\rightarrow$ Yêu cầu Content Service lấy câu hỏi \textbf{REMEDIAL} (Bổ trợ, độ khó thấp).
              \item Nếu \texttt{mastery\_score >= 50}: Người học đã nắm vững. $\rightarrow$ Yêu cầu câu hỏi \textbf{STANDARD} (Tiêu chuẩn, độ khó tăng dần).
          \end{itemize}
    \item Trả về câu hỏi cho Client.
\end{enumerate}

\subsection{Cơ sở Hạ tầng và Triển khai (Infrastructure)}

\indentpar \indentpar Hệ thống sử dụng \textbf{Docker Compose} để định nghĩa toàn bộ môi trường runtime, đảm bảo tính nhất quán giữa Dev và Prod (cho MVP).

\noindent\textbf{Cấu hình Mạng (Networking):}
Tất cả service nằm trong mạng cầu nối \texttt{its-network}. Service gọi nhau thông qua DNS name của Docker container (ví dụ: \texttt{http://content-service:8081}).

\noindent\textbf{Cấu hình RabbitMQ:}
\begin{verbatim}
environment:
  RABBITMQ_DEFAULT_USER: admintest
  RABBITMQ_DEFAULT_PASS: adminTest2025
ports:
  - "5672:5672"   # AMQP Protocol
  - "15672:15672" # Management UI
\end{verbatim}

\subsection{Kiểm thử Hệ thống (System Testing)}

\indentpar \indentpar Ngoài Unit Test, chúng tôi đã xây dựng kịch bản kiểm thử End-to-End (E2E) nằm trong thư mục \texttt{sources/tests/system} để xác minh toàn bộ luồng tích hợp:

\begin{enumerate}
    \item \textbf{Setup}: Khởi tạo dữ liệu câu hỏi mẫu vào \texttt{content\_db}.
    \item \textbf{Action}: Giả lập HTTP request nộp bài sai liên tục (Score = 0).
    \item \textbf{Verify 1}: Kiểm tra \texttt{scoring\_db} đã lưu submission.
    \item \textbf{Verify 2}: Kiểm tra RabbitMQ đã nhận message.
    \item \textbf{Verify 3}: Kiểm tra \texttt{learner\_db} thấy điểm mastery giảm.
    \item \textbf{Verify 4}: Gọi Adaptive Engine, mong đợi nhận được câu hỏi loại \texttt{REMEDIAL}.
\end{enumerate}

Kịch bản này chứng minh sự phối hợp chính xác giữa 4 microservice và message broker.